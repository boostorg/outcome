[
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.3 [Linux] Visual Studio 2017 [Windows] XCode 9 [MacOS]  It is worth turning on C++ 17 if you can, there are many usability and performance improvements. If your compiler implements the Concepts TS, it is worth turning support on. Support is automatically detected and used.\nPartially working compilers:\n GCC 5.4.1 is highly usable so long as you don\u0026rsquo;t use Outcome in a constexpr evaluation context. clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Outcome v2 is feature complete, meeting the feedback from the Boost peer review in May 2017. It is an all new code base, written entirely from scratch during the month of June 2017. It has completed three months of maturation, and will shortly be sent back to Boost for a second peer review. As a result, consider this library to beta quality and subject change if a second review demands it.\nThat said, the essentials here are the same as they were in v1. Indeed most code written for v1 should be convertible to v2 without too much effort.\nUsage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On BSD and OS X:\nfetch https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On Windows, simply download the raw file from above and place it wherever it suits you.\nUsage from the Conan package manager (thanks to Th√©o Delrieu for contributing this support)\nAt the command line, add the bintray repo for Outcome to conan:\nconan remote add outcome https://api.bintray.com/conan/ned14/Outcome  Now simply add this to your Conan build:\n[requires] Outcome/master@ned14/stable  Outcome will be made available by Conan at \u0026lt;outcome.hpp\u0026gt;.\nUsage as a git submodule Given that v2 is still under development, it is currently best used as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout develop git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/include/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable branch containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://dedi4.nedprod.com/static/files/outcome-v2.0-source-latest.tar.xz\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 6.3, clang 4.0 MacOS: XCode 9 Windows: VS2017   Running the unit test suite To run the unit test suite you will need cmake 3.1 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.1 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/use-matrix/",
	"title": "Decision matrix",
	"tags": [],
	"description": "",
	"content": "To help you decide whether Outcome would be useful for your particular problem, the following decision matrix may be useful.\ngraph LR;\rFAILURE{Failure is regularly passed upthe stack to be handled?}\rFAILURE ==\"Yes\"== FREQUENT{Occasional failure is likely?}\rFREQUENT ==\"Yes\"== OUTCOME[Use Outcome]\rEXCEPTION[Use C++ exceptionthrows]\rFREQUENT --\"No\"-- EXCEPTION\r graph LR;\rFIXED{Worst casebounded execution timesare important to you?}\rTABLE{Your compiler usestable-based EH?}\rOUTCOME[Use Outcome]\rEXCEPTION[Use C++ exceptionthrows]\rFIXED ==\"Yes\"== TABLE\rTABLE ==\"Yes\"== OUTCOME\rFIXED --\"No\"-- EXCEPTION\rTABLE --\"No\"-- EXCEPTION\r\ngraph TD;\rFAILURE{Failure handlinglogic is as important ormore important thansuccess handling logic?}\rCOST{The cost of fullytesting your codefor exception safetyisn't worth it toyour organisation?}\rAUDIT{Code peer reviewchecks correctness offailure handling first?}\rEXCEPTIONS{You compile withC++ exceptionsglobally disabled?}\rSAFETY{You wish to startadding exceptionthrowing code intoan older codebasenot written to beexception safe?}\rOUTCOME[Use Outcome]\rEXCEPTION[Use C++ exceptionthrows]\rFAILURE ==\"Yes\"== OUTCOME\rAUDIT ==\"Yes\"== OUTCOME\rCOST ==\"Yes\"== OUTCOME\rEXCEPTIONS ==\"Yes\"== OUTCOME\rSAFETY ==\"Yes\"== OUTCOME\rFAILURE --\"No\"-- EXCEPTION\rAUDIT --\"No\"-- EXCEPTION\rCOST --\"No\"-- EXCEPTION\rEXCEPTIONS --\"No\"-- EXCEPTION\rSAFETY --\"No\"-- EXCEPTION\r\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/problem/",
	"title": "Incommensurate E types",
	"tags": [],
	"description": "",
	"content": "Back in the tutorial section on Default Actions, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now set E = std::error_code as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.\nWe thus strongly recommend to users that for any given piece of code, always using the same E type across the codebase is very wise, except where you explicitly want to prevent implicit propagation of failure up a call stack e.g. local failures in some domain specific piece of code.\nHowever it is unreasonable to expect that any non-trivial codebase can make do with E = std::error_code. This is why Outcome allows you to use custom E types which carry payload in addition to an error code, yet still have the Default Actions of std::error_code, including lazy custom exception throw synthesis.\nAll this is good, but if library A uses result\u0026lt;T, libraryA::failure_info\u0026gt;, and library B uses result\u0026lt;T, libraryB::error_info\u0026gt; and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.\nThe application writer has one of three choices:\n In the application, the form of result used is result\u0026lt;T, std::variant\u0026lt;E1, E2, ...\u0026gt;\u0026gt; where E1, E2 \u0026hellip; are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.\n One can translate/map the third party\u0026rsquo;s failure type into the application\u0026rsquo;s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.\n One can type erase the third party\u0026rsquo;s failure type into some application failure type, which can later be reconstituted if necessary. This is the cleanest solution with the least coupling issues and no problems with mis-mapping, but it almost certainly requires the use of malloc which the previous two did not.\n  Things get even more complication in the presence of callbacks. If in the callback you supply to library A, you call library B, you may need to insert switch statement maps or other mechanisms to convert library B\u0026rsquo;s failures into something library A can understand, and then somehow extract that out \u0026ndash; preferably without loss of original information \u0026ndash; into the application\u0026rsquo;s failure handling mechanism if library A subsequently returns failure as well. This implies transmitting state by which to track these interrelated pieces of failure data.\nLet us see what Outcome can do to help the application writer address some of these issues, next.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/udt-err/",
	"title": "User defined error types",
	"tags": [],
	"description": "",
	"content": "Let us imagine a some user defined value type (udt) and some user defined error type (err):\nstruct udt\r{\rint a{0};\rexplicit udt(int _a)\r: a(_a)\r{\r}\rudt() = default;\rint operator*() const { return a; }\r};\rstruct err\r{\rint a{0};\rexplicit err(int _a)\r: a(_a)\r{\r}\rerr() = default;\r};\r View this code on Github\rFirstly, note that both the udt and err types can be constructed from an int. Thus this won\u0026rsquo;t compile:\nresult\u0026lt;udt, err\u0026gt; res(5); // fails to compile, cannot convert \u0026#39;int\u0026#39; to result\r View this code on Github\rThis is because all the implicit constructors self-disable because it could be ambiguous whether you might mean udt or err. This is not a problem, it just requires typing some more so you are explicit as to which you intend:\n// When it is not unambiguous which to construct, we must say which we want same as with std::variant\u0026lt;\u0026gt;\r result\u0026lt;udt, err\u0026gt; res(in_place_type\u0026lt;err\u0026gt;, 5);\r View this code on Github\rNow, what do you think will happen if we try to retrieve a udt from this result holding an err?\nresult\u0026lt;udt, err\u0026gt; res(in_place_type\u0026lt;err\u0026gt;, 5);\r// What happens here? What exception type is thrown?\r try\r{\rstd::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/value-or-error/",
	"title": "ValueOrError Concept",
	"tags": [],
	"description": "",
	"content": " Something not really mentioned until now is how Outcome interoperates with the proposed std::expected\u0026lt;T, E\u0026gt;, whose design lands in between outcome::unchecked\u0026lt;T, E\u0026gt; and outcome::checked\u0026lt;T, E\u0026gt;, both of which are simplified aliases for outcome::result\u0026lt;T, E\u0026gt; hard coding the NoValuePolicy to a fixed policy.\nExpected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.\nOutcome\u0026rsquo;s result\u0026lt;X, Y\u0026gt; will explicitly construct from any type matching the ValueOrError concept, which includes std::expected\u0026lt;A, B\u0026gt;, if A is constructible to X and B is constructible to Y. The ValueOrError concept in turn is true if and only if the input type has:\n A value_type and error_type member typedefs. A .has_value() observer returning a bool. .value() and .error() observers.  Implementation Outcome\u0026rsquo;s machinery for implementing ValueOrError conversion is user extensible by injection of specialisations of the value_or_error\u0026lt;DEST, SRC\u0026gt; type into the OUTCOME_V2_NAMESPACE::convert namespace.\nOutcome\u0026rsquo;s default convert::value_or_error\u0026lt;DEST, SRC\u0026gt; implementation explicitly excludes Outcome result and outcome types from the default mechanism as there is a major gotcha: Outcome\u0026rsquo;s .value() is often not callable in constexpr as it can throw, which makes this mechanism pretty much useless for constexpr code. Thus separate explicit converting constructors exist which constexpr convert from any Outcome type (though note that result construction from outcome does use the ValueOrError mechanism).\nExamples of how to implement your own convert::value_or_error\u0026lt;DEST, SRC\u0026gt; converter is demonstrated in the worked example, next.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens1/",
	"title": "-- What happens?",
	"tags": [],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Apparently no exception was thrown? Correct. Nor was a value printed, though this will randomly vary depending on your compiler, libraries, the wind blowing on the day \u0026hellip;\nYou will probably find this surprising. This is because the default action for a user-defined error type is undefined behaviour1.\nLet us demonstrate this by recompiling the code to use the undefined behaviour sanitiser and see what happens instead:\nned@lyta:~/outcome/build_posix$ export UBSAN_OPTIONS=print_stacktrace=1 ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts /home/ned/outcome/doc/src/snippets/../../../include/outcome/policy/detail/common.hpp:42:9: runtime error: execution reached a __builtin_unreachable() call #0 0x42a0dc in outcome_v2_1c2d524c::policy::detail::base::_ub() (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x42a0dc) #1 0x42a028 in void outcome_v2_1c2d524c::policy::detail::base::narrow_value_check\u0026lt;outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt; \u0026gt;(outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;*) (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x42a028) #2 0x429f0c in void outcome_v2_1c2d524c::policy::all_narrow::wide_value_check\u0026lt;outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt; \u0026gt;(outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;*) (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x429f0c) #3 0x4298d6 in outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;::value() \u0026amp; (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4298d6) #4 0x4295f1 in main (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4295f1) #5 0x7f3bd59c1f44 in __libc_start_main /build/eglibc-SvCtMH/eglibc-2.19/csu/libc-start.c:287 #6 0x4030c3 in _start (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4030c3)  The undefined behaviour is correctly trapped at runtime by the undefined behaviour sanitiser.\n Note that this is hard undefined behaviour. The compiler (if GCC, clang, or MSVC) is explicitly told that observation of a value which is not present can never happen. The optimiser will thus generate code assuming it can never happen. This is what causes the segmentation fault above, no assembler is generated for the no-value observation case which causes corruption of the CPU registers, thus making visible early the undefined behaviour.\r[return]   "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/anatomy/",
	"title": "Anatomy of a policy",
	"tags": [],
	"description": "",
	"content": "A NoValuePolicy is quite simple. This is a complete policy, only the top two thirds is needed if you never use the policy in an outcome.\nstruct blank_policy\r{\r//! Performs a narrow check of state, used in the assume_value() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl \u0026amp;\u0026amp;self) noexcept;\r//! Performs a narrow check of state, used in the assume_error() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl \u0026amp;\u0026amp;self) noexcept;\r//! Performs a wide check of state, used in the value() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl \u0026amp;\u0026amp;self);\r//! Performs a wide check of state, used in the error() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl \u0026amp;\u0026amp;self);\r/******** These only used if the policy is used in Outcome ********/\r//! Performs a narrow check of state, used in the assume_exception() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl \u0026amp;\u0026amp;self) noexcept;\r//! Performs a wide check of state, used in the exception() functions.\r template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl \u0026amp;\u0026amp;self);\r};\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/keeping_state/",
	"title": "Keeping state",
	"tags": [],
	"description": "",
	"content": "The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result\u0026lt;T, std::pair\u0026lt;error_code, std::unique_ptr\u0026lt;stack_backtrace\u0026gt;\u0026gt;\u0026gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.\nWe therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.\n/* Outcome\u0026#39;s hook mechanism works vis ADL, so we will need a custom namespace\rto ensure the hooks apply only to the types declared in this namespace only\r*/\rnamespace error_code_extended\r{\r// The extra error information we will keep\r struct extended_error_info\r{\rstd::array\u0026lt;void *, 16\u0026gt; backtrace; // The backtrace\r size_t items; // Items in backtrace array which are valid\r };\rstruct mythreadlocaldata_t\r{\r// Keep 16 slots of extended error info as a ringbuffer\r extended_error_info slots[16];\r// The current oldest slot\r uint16_t current{0};\r// Return the oldest slot\r extended_error_info \u0026amp;next() { return slots[(current++) % 16]; }\r// Retrieve a previously stored slot, detecting if it is stale\r extended_error_info *get(uint16_t idx)\r{\r// If the idx is stale, return not found\r if(idx - current \u0026gt;= 16)\r{\rreturn nullptr;\r}\rreturn slots + (idx % 16);\r}\r};\r// Meyer singleton returning a thread local data structure for this thread\r inline mythreadlocaldata_t \u0026amp;mythreadlocaldata()\r{\rstatic thread_local mythreadlocaldata_t v;\rreturn v;\r}\r}\r View this code on Github\rThe extended error info is kept in a sixteen item long ring buffer. We continuously increment the current index pointer which is a 16 bit value which will wrap after 65,535. This lets us detect an attempt to access recycled storage, and thus return item-not-found instead of the wrong extended error info.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/limitations/",
	"title": "Limitations",
	"tags": [],
	"description": "",
	"content": "C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:\n A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should annotated with extern \u0026quot;C\u0026quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI. You cannot use overloading in your extern \u0026quot;C\u0026quot; functions. You may only use types in your C++ function for which these traits are both true:  std::is_standard_layout_v\u0026lt;T\u0026gt; std::is_trivially_copyable_v\u0026lt;T\u0026gt;  Your C++ function should return either a result\u0026lt;T, E\u0026gt; or a result\u0026lt;T\u0026gt; i.e. with the EC defaulted to std::error_code or something with equal layout. Note that std::error_code has standard layout, and is trivially copyable, and thus is a legal type in C.  These might seem to be showstoppers to C++ programmers, but with a bit of care during library design, you can actually express a lot of complex C++ and still meet these requirements. For example, more than 80% of the APIs in my C++ 17 AFIO library (which I hope to propose in 2018 to become the File I/O TS for C++ 24) meets the above restrictions, and thus can be called directly from C code or any programming language which speaks the C ABI.\nA useful tip is to sprinkle static_assert() testing the two traits above around your header files for any types which can traverse the C ABI boundary, and add extern \u0026quot;C\u0026quot; free function thunks for your class member functions1. You should be ready to go from the C++ side at least.\n Or simply write a script to do this for you. A starter script can be found at https://github.com/ned14/afio/blob/master/scripts/make_free_functions.py.\r[return]   "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file/",
	"title": "The Filesystem TS",
	"tags": [],
	"description": "",
	"content": "Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.\nConsider the copy_file() API from the Filesystem TS:\nnamespace filesystem\r{\r/*! Copies the file at path `from` to path `to`.\r\\returns True if file was successfully copied.\r\\throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with\r`ec` being the error code reported by the operating system.\r*/\rbool copy_file(const path \u0026amp;from, const path \u0026amp;to);\r/*! Copies the file at path `from` to path `to`.\r\\returns True if file was successfully copied. If false, `ec` is written with\rthe error code reported by the operating system.\r\\throws Never throws.\r*/\rbool copy_file(const path \u0026amp;from, const path \u0026amp;to, std::error_code \u0026amp;ec) noexcept;\r}\r View this code on Github\rBefore Outcome, the common design pattern was to provide throwing and non-throwing overloads of every API. As you can see above, the throwing API throws a filesystem::filesystem_error exception type which carries additional information, specifically two paths. These paths may refer to the files which were the source of any failure. However the non-throwing overload does not provide this additional information, which can make it more annoying to use the non-throwing overload sometimes.\nWhat if we could replace these two overloads of every API in the Filesystem TS with a single API, and additionally have the non-throwing edition return the exact same additional information as the throwing edition?\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/httplib/",
	"title": "The HTTP library",
	"tags": [],
	"description": "",
	"content": "Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.\nLet us imagine that the HTTP library has the following public interface:\n// This is some standalone library implementing high level HTTP\rnamespace httplib\r{\r// These are the error code that this HTTP library can return\r enum class status_code\r{\rsuccess = 0, // not the HTTP success code of 200\r\r// A subset of all HTTP status codes for brevity\r bad_request = 400,\raccess_denied = 401,\rlogon_failed = 402,\rforbidden = 403,\rnot_found = 404,\rinternal_error = 500\r};\r// This is the error type that this HTTP library can return\r struct failure\r{\rstatus_code status{status_code::success};\rstd::string url{}; // The failing URL\r };\r// Localise a result implementation to this library\r template \u0026lt;class T\u0026gt; using result = BOOST_OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure\u0026gt;;\r/* Performs a HTTP GET on the url, returning the body if successful,\ra failure with status_code if unsuccessful at the HTTP level, or a\rC++ exception throw if something catastrophic happened e.g. bad_alloc\r*/\rresult\u0026lt;std::string\u0026gt; get(std::string url);\r}\r View this code on Github\rThe HTTP library is a mixed-failure design. Likely failures (HTTP status codes) are returned via httplib::failure, unlikely failures (e.g. out of memory) are returned via throw of the usual STL exception types.\nThe sole API we bother describing is an implementation of HTTP GET. It fetches a URL, and either returns the contents or the failure reason why not.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "\r\rresult\u0026lt;T, EC\u0026gt;\rGentle introduction to writing code with simple success-or-failure return types.\n\rInspecting result\u0026lt;T, EC\u0026gt;\rTRY operations\r\routcome\u0026lt;T, EC, EP\u0026gt;\rSuccess-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.\n\rInspecting outcome\u0026lt;T, EC, EP\u0026gt;\r\rCustom payloads\rSuccess-or-failure return types where extra information in addition to the error code accompanies failure.\n\rThe Filesystem TS\rUpgrading the Filesystem TS\rAuto-throwing filesystem_error\r\rDefault actions\rThe default rules for handling different categories of failure type\n\rUser defined error types\r-- What happens?\rError code enums\r-- What happens?\r-- Now what happens?\rerror_code\rexception_ptr\rvoid\runchecked\u0026lt;T, E\u0026gt; and checked\u0026lt;T, E\u0026gt;\r\rResult returning constructors\rHow to metaprogram construction of objects which use result\u0026lt;T, EC\u0026gt; to return failure instead of throwing a C\u0026#43;\u0026#43; exception.\n\rTwo phase construction\rA file handle\rPhase 2 construction\rPhase 3\rconstruct\u0026lt;T\u0026gt;\rAlternatives\r\rHooking events\rIntercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.\n\rKeeping state\rADL bridging\rHook result\rCustom exception ptr\rHook outcome\r\rPolicies\rDefining your own NoValuePolicy policies, plus an overview of the precanned policies which come in the Outcome source code.\n\rAnatomy of a policy\rCasting workaround\rBuilt-in policies\r\rUsing result\u0026lt;T\u0026gt; from C code\rInteracting with result\u0026lt;T, EC\u0026gt; returning C\u0026#43;\u0026#43; functions from C code.\n\rLimitations\rExample C\u0026#43;\u0026#43; function\rCalling it from C\rVariations\r\rInteroperation\rInteroperating with std::expected\u0026lt;T, E\u0026gt; and other ValueOrError concept matching types.\n\rIncommensurate E types\rValueOrError Concept\rThe HTTP library\rThe HTMLTidy library\rThe File I/O library\rThe Application\rMapping the HTTP library into the Application 1/2\rMapping the HTTP library into the Application 2/2\rMapping the File I/O library into the Application\rMapping the HTMLTidy library into the Application\rIn use\rConclusion\r\rCustom error codes\rIllustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.\n\r\r\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/two-phase-init/",
	"title": "Two phase construction",
	"tags": [],
	"description": "",
	"content": "The first thing to do is to break your object\u0026rsquo;s construction into two phases:\n Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1. If you need to initialise a member variable without a constexpr constructor, std::optional\u0026lt;T\u0026gt; is the usual workaround.\n Do the remainder of the construction, the parts which could fail. Because phase 1 placed the object into a legally destructible state, it is usually the case that one can bail out during phase 2 and the destructor will clean things up correctly.\n  The phase 1 construction will be placed into a private constexpr constructor so nobody external can call it. The phase 2 construction will be placed into a static member initialisation function which returns a result with either the successfully constructed object, or the cause of any failure to construct the object.\nFinally, as a phase 3, some simple metaprogramming will implement a construct\u0026lt;T\u0026gt;{}(Args...) free function which will construct any object T by calling its static initialisation function with Args... and returning the result returned. This isn\u0026rsquo;t as nice as calling T(Args...) directly, but it\u0026rsquo;s not too bad in practice. And more importantly, it lets you write generic code which can construct any unknown object which fails via returning result, completely avoiding C++ exception throws.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/",
	"title": "result&lt;T, EC&gt;",
	"tags": [],
	"description": "Gentle introduction to writing code with simple success-or-failure return types.",
	"content": " Outcome 2.0 namespace It is recommended that you refer to entities from this Outcome 2.0 via the following namespace alias:\nnamespace outcome = BOOST_OUTCOME_V2_NAMESPACE;\r View this code on Github\rAs patches and modifications are applied to this library, namespaces get permuted in order not to break any backward compatibility. At some point namespace outcome::v2 will be defined, and this will be the prefered namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome::v2.\nCreating result\u0026lt;\u0026gt; We will define a function that converts an std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept;\r View this code on Github\rClass template result\u0026lt;T, EC\u0026gt; has two template parameters. The first (T) represents the type of the object returned from the function upon success; the second (EC) is the type of object containing information about the reason for failure when the function fails. A result\u0026lt;T, EC\u0026gt; object either stores a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code. If both T and EC are trivially copyable, result\u0026lt;T, EC\u0026gt; is also trivially copyable.\nNow, we will define an enumeration describing different failure situations during conversion.\nenum class ConversionErrc\r{\rEmptyString = 1, // 0 is never an error\r IllegalChar = 2,\rTooLong = 3,\r};\r// all boilerplate necessary to plug ConversionErrc\r// into std::error_code framework\r View this code on Github\rAssume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept\r{\rif (str.empty())\rreturn ConversionErrc::EmptyString;\rif (!std::all_of(str.begin(), str.end(), ::isdigit))\rreturn ConversionErrc::IllegalChar;\rif (str.length() \u0026gt; 9)\rreturn ConversionErrc::TooLong;\rreturn atoi(str.c_str());\r}\r View this code on Github\rresult\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that the conversion is not ambiguous. If some type X is both convertible to T and EC, conversion to result\u0026lt;T, EC\u0026gt; fails to compile. In this case you need to use one of the tagged constructors:\noutcome::result\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString};\routcome::result\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1};\r View this code on Github\rOr use helper factory functions:\noutcome::result\u0026lt;int\u0026gt; r = outcome::failure(ConversionErrc::EmptyString); outcome::result\u0026lt;int\u0026gt; s = outcome::success(1);\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/tidylib/",
	"title": "The HTMLTidy library",
	"tags": [],
	"description": "",
	"content": "// There actually is a library for tidying HTML into XHTML called HTMLTidy\r// See http://www.html-tidy.org/\r// HTMLTidy is actually a great tool, I highly recommend it.\r\r// This isn\u0026#39;t the API for Tidy, but let\u0026#39;s assume it\u0026#39;s a C library returning\r// errno domained error codes. out must be freed with free() after use.\rextern \u0026#34;C\u0026#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen);\r View this code on Github\rA C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a \u0026ldquo;split\u0026rdquo; T|E API. The above is an example of exactly that form of \u0026ldquo;split\u0026rdquo; T|E API.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/file_handle/",
	"title": "A file handle",
	"tags": [],
	"description": "",
	"content": "Borrowing from afio::file_handle which uses this design pattern, here is a simplified file_handle implementation:\nclass file_handle\r{\rint _fd{-1}; // file descriptor\r struct stat _stat\r{\r0\r}; // stat of the fd at open\r\r// Phase 1 private constexpr constructor\r constexpr file_handle() {}\rpublic:\rusing path_type = filesystem::path;\r//! The behaviour of the handle: does it read, read and write, or atomic append?\r enum class mode : unsigned char // bit 0 set means writable\r {\runchanged = 0,\rnone = 2, //!\u0026lt; No ability to read or write anything, but can synchronise (SYNCHRONIZE or 0)\r attr_read = 4, //!\u0026lt; Ability to read attributes (FILE_READ_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)\r attr_write = 5, //!\u0026lt; Ability to read and write attributes (FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)\r read = 6, //!\u0026lt; Ability to read (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONISE or O_RDONLY)\r write = 7, //!\u0026lt; Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONISE or O_RDWR)\r append = 9 //!\u0026lt; All mainstream OSs and CIFS guarantee this is atomic with respect to all other appenders (FILE_APPEND_DATA|SYNCHRONISE or O_APPEND)\r };\r// Moves but not copies permitted\r file_handle(const file_handle \u0026amp;) = delete;\rfile_handle(file_handle \u0026amp;\u0026amp;o) noexcept : _fd(o._fd) { o._fd = -1; }\rfile_handle \u0026amp;operator=(const file_handle \u0026amp;) = delete;\rfile_handle \u0026amp;operator=(file_handle \u0026amp;\u0026amp;o) noexcept\r{\rthis-\u0026gt;~file_handle();\rnew(this) file_handle(std::move(o));\rreturn *this;\r}\r// Destruction closes the handle\r ~file_handle()\r{\rif(_fd != -1)\r{\rif(-1 == ::close(_fd))\r{\rint e = errno;\rstd::cerr \u0026lt;\u0026lt; \u0026#34;FATAL: Closing the fd during destruction failed due to \u0026#34; \u0026lt;\u0026lt; strerror(e) \u0026lt;\u0026lt; std::endl;\rstd::terminate();\r}\r_fd = -1;\r}\r}\r// Phase 2 static member constructor function, which cannot throw\r static inline outcome::result\u0026lt;file_handle\u0026gt; file(path_type path, mode mode = mode::read) noexcept;\r};\r View this code on Github\rNote the default member initialisers, these are particularly convenient for implementing phase 1 of construction. Note also the constexpr constructor, which thanks to the default member initialisers is otherwise empty.\nFile handles are very expensive to copy as they involve a syscall to duplicate the file descriptor, so we enable moves only.\nThe destructor closes the file descriptor if it is not -1, and if the close fails, seeing as there is nothing else we can do without leaking the file descriptor, we fatal exit the process.\nFinally we declare the phase 2 constructor which is a static member function.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/adl_bridging/",
	"title": "ADL bridging",
	"tags": [],
	"description": "",
	"content": "In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered throw_as_system_error_with_payload() function was to be found.\nHere we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.\nnamespace error_code_extended\r{\r// Use the error_code type as the ADL bridge for the hooks by creating a type here\r // It can be any type that your localised result uses, including the value type but\r // by localising the error code type here you prevent nasty surprises later when the\r // value type you use doesn\u0026#39;t trigger the ADL bridge.\r struct error_code : public std::error_code\r{\r// literally passthrough\r using std::error_code::error_code;\rerror_code() = default;\rerror_code(std::error_code ec)\r: std::error_code(ec)\r{\r}\r};\r// Localise result and outcome to using the local error_code so this namespace gets looked up for the hooks\r template \u0026lt;class R\u0026gt; using result = BOOST_OUTCOME_V2_NAMESPACE::result\u0026lt;R, error_code\u0026gt;;\rtemplate \u0026lt;class R\u0026gt; using outcome = BOOST_OUTCOME_V2_NAMESPACE::outcome\u0026lt;R, error_code /*, std::exception_ptr */\u0026gt;;\r}\r View this code on Github\rFor convenience, we template alias local copies of result and outcome in this namespace bound to the ADL bridging error_code.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/cast/",
	"title": "Casting workaround",
	"tags": [],
	"description": "",
	"content": "The templated Impl type on each policy function is decltype(*this) of the part of Outcome\u0026rsquo;s internal implementation which calls the policy. It therefore may be quite removed from the actual outcome type in play, and thus the .exception() member function and others belonging to outcome only will not be immediately visible.\nHence a very common thing you\u0026rsquo;ll need to do is static cast to a more derived form before use like this:\ntemplate \u0026lt;class T, class EC, class E\u0026gt; struct outcome_policy\r{\r/*! Performs a wide check of state, used in the value() functions.\r\\effects If outcome does not have a value, if it has an exception it rethrows it via `std::rethrow_exception()`,\rif has an error it throws a `std::system_error(error())`, else it throws `bad_outcome_access`.\r*/\rtemplate \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(const Impl \u0026amp;self)\r{\r// All of the have_*() state check functions are always present in all Impl types\r if(!self.have_value())\r{\rif(self.have_exception())\r{\r// .value() is implemented by the result part of Outcome. It knows nothing\r // of outcome\u0026#39;s .exception(), so we need to cast to the derived type first.\r const MyOutcomeType \u0026amp;_self = static_cast\u0026lt;const MyOutcomeType \u0026amp;\u0026gt;(self);\r// Note this will invoke narrow_exception_check() in this policy\r std::rethrow_exception(_self.assume_exception());\r}\rif(self.have_error())\r{\rthrow std::system_error(make_error_code(self.assume_error()));\r}\rthrow bad_outcome_access(\u0026#34;no value\u0026#34;);\r}\r}\r};\r View this code on Github\rNote that const-ness and lvalue/rvalue-ness is propagated to Impl \u0026amp;\u0026amp;self, so if the result or outcome is a const rvalue and the user calls .value() on that, the wide_value_check() will see a const rvalue self. This lets you move from self when implementing the wide value check appropriately.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/enums/",
	"title": "Error code enums",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s replace err with something likely in many people\u0026rsquo;s code, a strongly typed enum:\nstruct udt\r{\rint a{0};\rexplicit udt(int _a)\r: a(_a)\r{\r}\rudt() = default;\rint operator*() const { return a; }\r};\renum class err\r{\rsuccess, // REMEMBER it is best practice to always put \u0026#34;success\u0026#34;\r failure1, // with value 0 as your first item in any error code\r failure2 // enum, even if you never use it.\r };\rresult\u0026lt;udt, err\u0026gt; res(err::failure1);\r// What happens here? What exception type is thrown?\r try\r{\rstd::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example/",
	"title": "Example C++ function",
	"tags": [],
	"description": "",
	"content": "Let us start with a simple C++ function which we wish to make available to C code:\n// Fill the supplied buffer with the integer v converted to a string, returning\r// length of string minus null terminator\rextern \u0026#34;C\u0026#34; outcome::result\u0026lt;size_t\u0026gt; to_string(char *buffer, size_t bufferlen, int v) noexcept\r{\rtry\r{\r// Could throw an exception!\r std::string temp(std::to_string(v));\r// Will this string exceed the supplied buffer?\r if(temp.size() + 1 \u0026gt; bufferlen)\rreturn std::errc::no_buffer_space;\r// Copy the string into the supplied buffer, and return length of string\r memcpy(buffer, temp.data(), temp.size() + 1);\rreturn temp.size();\r}\rcatch(...)\r{\r// This utility function rethrows the C++ exception, matching it\r // against every standard library exception and generating an\r // error code exactly matching it if possible. So, if the\r // string creation threw std::bad_alloc, that would be converted\r // into make_error_code(std::errc::not_enough_memory).\r return outcome::error_from_exception();\r}\r}\r View this code on Github\rA surprise to some may be that one can return an outcome::result\u0026lt;size_t\u0026gt; from a C function! This is because if for some result\u0026lt;T, EC\u0026gt; where both T and EC have standard layout and are trivially copyable, then Outcome guarantees so will result\u0026lt;T, EC\u0026gt;. Thus outcome::result\u0026lt;size_t\u0026gt; is a perfectly legal C type, and can be returned directly to C code.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/inspecting/",
	"title": "Inspecting result&lt;T, EC&gt;",
	"tags": [],
	"description": "",
	"content": "Suppose we will be writing function print_half that takes an integral number (however big) represented as an std::string and outputs a number which is twice smaller:\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text);\r View this code on Github\rType result\u0026lt;void\u0026gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. Class template result\u0026lt;\u0026gt; is declared with attribute [[nodiscard]], which means compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represnted by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use function convert defined in the previous section.\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text)\r{\rif (outcome::result\u0026lt;int\u0026gt; r = convert(text)) // #1\r {\rstd::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2\r }\relse\r{\rif (r.error() == ConversionErrc::TooLong) // #3  {\rBOOST_OUTCOME_TRY (i, BigInt::fromString(text)); // #4\r std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl;\r}\relse\r{\rreturn r.as_failure(); // #5\r }\r}\rreturn outcome::success(); // #6\r}\r View this code on Github\r#1. You test if result\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. Function .value() extracts the successfully returned BigInt.\n#3. Function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the function call in the second argument returns a result\u0026lt;\u0026gt;. It is defined as:\n/*static*/ outcome::result\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s)\r View this code on Github\rOur control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of result\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type int with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type int is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but it would not work if we were using outcome\u0026lt;\u0026gt; instead of result\u0026lt;\u0026gt; \u0026ndash; this will be covered later.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/filelib/",
	"title": "The File I/O library",
	"tags": [],
	"description": "",
	"content": "The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:\n// You may remember this from the tutorial section on Custom Payloads\rnamespace filelib\r{\r// Error code + paths related to a failure. Also causes ADL discovery to check this namespace.\r struct failure_info\r{\rstd::error_code ec;\rpath path1{}, path2{};\r};\r// Tell Outcome that failure_info is to be treated as a std::error_code\r inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; }\r// Tell Outcome that no-value observation should throw a custom exception\r inline void throw_as_system_error_with_payload(failure_info fi)\r{\r// If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.\r BOOST_OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec);\r// Throw the exact same filesystem_error exception which the throwing copy_file() edition does.\r throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec);\r}\r// Localise a result implementation specific to this namespace.\r template \u0026lt;class T\u0026gt; using result = BOOST_OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure_info\u0026gt;;\r// Writes a chunk of data to some file. Returns bytes written, or failure_info. Never throws exceptions.\r result\u0026lt;size_t\u0026gt; write_file(string_view chunk) noexcept;\r}\r View this code on Github\rThis uses the advanced Outcome feature of programming the lazy synthesis of custom C++ exception throws from a payload carrying E type called failure_info. Like the HTTP library, it too template aliases a localised result implementation into its namespace with ADL bridging so Outcome customisation points can be discovered.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file2/",
	"title": "Upgrading the Filesystem TS",
	"tags": [],
	"description": "",
	"content": "An Outcome based solution to the dual overload problem is straightforward:\nnamespace filesystem2\r{\r// Error code + paths related to a failure. Also causes ADL discovery to check this namespace.\r struct failure_info\r{\rstd::error_code ec;\rpath path1, path2;\r};\r// Tell Outcome that failure_info is to be treated as a std::error_code\r inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; }\r// Localise an outcome implementation specific to this namespace. Normally would just\r // be `result`, but for clarity we\u0026#39;ll use `fs_result`.\r template \u0026lt;class T\u0026gt; using fs_result = outcome::result\u0026lt;T, failure_info\u0026gt;;\r/*! Copies the file at path `from` to path `to`.\r\\returns Successful if file was successfully copied, otherwise the error code reported\rby the operating system plus a payload of the paths involved.\r\\throws Never throws.\r*/\rfs_result\u0026lt;void\u0026gt; copy_file(const path \u0026amp;from, const path \u0026amp;to) noexcept;\r}\r View this code on Github\rStarting at the bottom, there is now a single copy_file() function which returns a fs_result\u0026lt;void\u0026gt;. As result is either successful or not, there is no longer any point in returning a boolean, so we simply return void on success. On failure, as the template alias fs_result\u0026lt;T\u0026gt; above it shows, we are returning a failure_info structure containing an error code and the same additional information as filesystem_error provides.\nIt is important to note that the fact that failure_info is defined in namespace filesystem2 is very important. This is because Outcome uses Argument Dependent Lookup (ADL) to find the make_error_code() function, as well as other customisation point free functions. In other words, only the namespaces as defined by ADL are searched when finding a free function telling us what to do for failure_info, which includes the namespace failure_info is declared into.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/outcome/",
	"title": "outcome&lt;T, EC, EP&gt;",
	"tags": [],
	"description": "Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.",
	"content": " outcome\u0026lt;\u0026gt; Type outcome\u0026lt;T, EC, EP\u0026gt; can store either a T or an EC or an EP. The first parameter (T) represents a value returned from functions upon success. Both EC and EP represent the reason for function failure when function fails. Conceptually, outcome\u0026lt;T, EC, EP\u0026gt; can be thought of as variant\u0026lt;T, EC, EP\u0026gt; or variant\u0026lt;T, variant\u0026lt;EC, EP\u0026gt;\u0026gt;, or result\u0026lt;T, variant\u0026lt;EC, EP\u0026gt;\u0026gt;. EC defaults to std::error_code and EP defaults to std::exception_ptr. The distinction is made into two types, EC and EP for the following reasosns:\n The interface: EC is inspected in a different way that EP. Performance: handling of EC is optimized for POD types. Interoperability with result\u0026lt;T, EC\u0026gt;.  outcome\u0026lt;T, EC, EP\u0026gt; is useful for transporting exceptions across layers of the program that were never designed with exception safety in mind.\nConsider a program consisting of three layers:\ngraph BT\rL3[\"Layer3\"]\rL2[\"Layer2NX\"] -- L3\rL1[\"Layer1\"] -- L2\r The highest-level layer, Layer3, uses exceptions for signalling failures. The middle layer, Layer2NX, was not designed with exception safety in mind and functions need to return information about failures in return value. But down in the implementation details, in Layer1, another library is used that again throws exceptions. The goal is to be able to transfer an exception thrown in Layer1 through Layer2NX, which is not exception-safe, and be able to rethrow it in Layer3.\nIn Layer1 we have a throwing function:\nnamespace Layer1\r{\rauto f() -\u0026gt; int; // may throw\r}  View this code on Github\rIn Layer2NX we cannot use exceptions, so its function g uses result\u0026lt;\u0026gt; to report failures:\nnamespace Layer2NX\r{\rauto g() noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; ;\r}\r View this code on Github\rThere is another function in Layer2NX that has to use both Layer1::f and Layer2NX::g. It cannot use Layer1::f directly as the later may throw an exception, so it has to wrap it into a non-throwing function Layer2NX::f:\nnamespace Layer2NX\r{ auto f() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; try {\rreturn Layer1::f();\r}\rcatch (...) {\rreturn std::current_exception();\r}\r}  View this code on Github\rThis wrapper funciton returns type outcome\u0026lt;int\u0026gt;. If an exception is thrown, it is caught by an std::exception_ptr. This std::exception_ptr is converted to outcome\u0026lt;T\u0026gt; upon return. outcome\u0026lt;T, EC, EP\u0026gt; is convertible from T, EC and EP as long as such conversion is not ambiguous.\nNow function Layer2NX::fun can be implemented with non-throwing Layer2NX::f and Layer2NX::g:\nnamespace Layer2NX\r{ auto fun() noexcept -\u0026gt; outcome::outcome\u0026lt;double\u0026gt; {\rResource* resource = new (std::nothrow) Resource;\rif (!resource)\rreturn std::errc::not_enough_memory;\routcome::outcome\u0026lt;int\u0026gt; fr = Layer2NX::f();\rif (!fr) {\rdelete resource;\rreturn fr.as_failure(); // #1\r }\rdouble ans = resource-\u0026gt;use(fr.value());\routcome::result\u0026lt;int\u0026gt; gr = Layer2NX::g();\rif (!gr) {\rdelete resource;\rreturn gr.as_failure(); // #2\r }\rans += resource-\u0026gt;use(gr.value());\rdelete resource;\rreturn ans;\r}\r}\r View this code on Github\rIn the example above, manually deleting resource represents a non-exception-safe code. Typically it is not recommended to manually delete memory because it is hard to get right in case exceptions are thrown. But when exceptions are known not to be thrown (e.g., when they are disabled) this recommendation is weakened.\n#1. When we want to forward (return up) the outcome\u0026lt;\u0026gt; object representing failure, we use function as_failure() it returns type failure_type\u0026lt;EC, EP\u0026gt; which is convertible to any to outcome\u0026lt;T, EC, EP\u0026gt; for any T.\n#2. We can similarly forward a failure from result\u0026lt;\u0026gt; again by calling as_failure(), the result will be converted to outcome\u0026lt;\u0026gt; preserving the information about function failure.\nIf the management of resource is automated through RAII, even with exceptions disabled, you can use OUTCOME_TRY to make the code more concise:\nnamespace Layer2NX\r{ auto fun2() noexcept -\u0026gt; outcome::outcome\u0026lt;double\u0026gt; {\rstd::unique_ptr\u0026lt;Resource\u0026gt; resource {new (std::nothrow) Resource};\rif (!resource)\rreturn std::errc::not_enough_memory;\rBOOST_OUTCOME_TRY (fr, Layer2NX::f());\rdouble ans = resource-\u0026gt;use(fr);\rBOOST_OUTCOME_TRY (gr, Layer2NX::g());\rans += resource-\u0026gt;use(gr);\rreturn ans;\r}\r}\r View this code on Github\rStatement OUTCOME_TRY works for outcome and you can also use it to return failure from result\u0026lt;\u0026gt; as outcome\u0026lt;\u0026gt; as shown in the second OUTCOME_TRY.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens2/",
	"title": "-- What happens?",
	"tags": [],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums1 Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Also undefined behaviour. This is because Outcome doesn\u0026rsquo;t know what to do with a strongly typed enum any more than some user defined struct.\nLet us register our error code enum with the C++ standard library. This causes Outcome to treat it quite differently.\nstruct udt\r{\rint a{0};\rexplicit udt(int _a)\r: a(_a)\r{\r}\rudt() = default;\rint operator*() const { return a; }\r};\renum class err\r{\rsuccess,\rfailure1,\rfailure2\r};\r// Tell the standard library that enum err is an error code enum\r// by specialising the is_error_code_enum trait. See\r// http://en.cppreference.com/w/cpp/error/error_code/is_error_code_enum\rnamespace std\r{\rtemplate \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;err\u0026gt; : std::true_type\r{\r};\r}\r// We also must declare a free function make_error_code. This is\r// discovered via ADL by the standard library. See\r// http://en.cppreference.com/w/cpp/error/errc/make_error_code\rinline std::error_code make_error_code(err c)\r{\r// We need to inherit from std::error_category to define\r // an error code domain with the standard library for\r // our strongly typed enum. See\r // http://en.cppreference.com/w/cpp/error/error_category\r static struct err_category : std::error_category\r{\rvirtual const char *name() const noexcept override final { return \u0026#34;err_category\u0026#34;; };\rvirtual std::string message(int c) const override final\r{\rswitch(static_cast\u0026lt;err\u0026gt;(c))\r{\rcase err::success:\rreturn \u0026#34;err::success\u0026#34;;\rcase err::failure1:\rreturn \u0026#34;err::failure1\u0026#34;;\rcase err::failure2:\rreturn \u0026#34;err::failure2\u0026#34;;\r}\rreturn \u0026#34;unknown\u0026#34;;\r}\r} category;\rreturn std::error_code(static_cast\u0026lt;int\u0026gt;(c), category);\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app/",
	"title": "The Application",
	"tags": [],
	"description": "",
	"content": "The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.\n// This is the namespace of the application which is connecting together the httplib,\r// filelib and tidylib libraries into a solution.\rnamespace app\r{\r// Create an ADL bridge so copy/move hooks will be searched for in this namespace\r struct error_code : public std::error_code\r{\r// passthrough\r using std::error_code::error_code;\rerror_code() = default;\rerror_code(std::error_code ec)\r: std::error_code(ec)\r{\r}\r};\r// Localise an outcome implementation for this namespace\r template \u0026lt;class T\u0026gt; using outcome = BOOST_OUTCOME_V2_NAMESPACE::outcome\u0026lt;T, error_code /*, std::exception_ptr */\u0026gt;;\rusing BOOST_OUTCOME_V2_NAMESPACE::success;\r}\r View this code on Github\rHere we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.\nThe way we are going to configure interop is as follows:\n The application shall use error_code for anticipated failure and C++ exception throws for unanticipated failure. We shall choose the convention that app::outcome with exception ptr solely and exclusively represents a type erased failure from a third party library.  Thus if one calls .value() on an app::outcome, both anticipated failure within the app and type erased failure from a third party library shall be converted to a C++ exception throw.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens3/",
	"title": "-- Now what happens?",
	"tags": [],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums2 Exception thrown was failure1 ned@lyta:~/outcome/build_posix$  Ah so now we are throwing a C++ exception on no-value observation! This is because we registered our error code enum with the C++ standard library and in so doing, we also told the standard library how our error code interacts with std::error_code and thus std::system_error.\nOutcome\u0026rsquo;s default action when no-value observing a result or outcome with a EC type where some ADL discovered free function make_error_code(EC) returning a std::error_code exists1, is to throw a std::system_error(make_error_code(.error())). This is how the failure_info custom EC type was annotated to be treated as a std::error_code in the previous section of the tutorial, this is the exact same mechanism2.\nSo above, because .error() is set to err::failure1, the free function we defined make_error_code(err) converts that into a std::error_code, and from that the std::system_error is constructed and thrown during a no-value value observation.\nOn catching a std::exception, we print the what() which this particular standard library implementation (libstdc++) has chosen to set to error_code::message().\n trait::has_error_code\u0026lt;EC\u0026gt; determines this.\r[return] One only needs to additionally define the throw_as_system_error_with_payload() free function if type EC does not have std::is_error_code_enum\u0026lt;EC\u0026gt; nor std::is_error_condition_enum\u0026lt;EC\u0026gt; defined as true. [return]   "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file3/",
	"title": "Auto-throwing filesystem_error",
	"tags": [],
	"description": "",
	"content": "Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.\nSeeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.\nTelling Outcome how to throw a filesystem_error with payload of the failing paths is easy:\nnamespace filesystem2\r{\r// If we would like Outcome to do something other than the default action (see next\r // section), we can declare this ADL discovered free function to customise what\r // to do instead.\r //\r // Note that rvalue semantics are propagated internally by Outcome, so if the user\r // called .value() on a rvalued result, failure_info will be moved rather than\r // copied from the result. That means we can overload once with value semantics,\r // and not need to overload for lvalue and rvalue situations unless we really feel\r // we need to for some reason.\r inline void throw_as_system_error_with_payload(failure_info fi)\r{\r// If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.\r outcome::try_throw_std_exception_from_error(fi.ec);\r// Throw the exact same filesystem_error exception which the throwing copy_file() edition does.\r throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec);\r}\r}\r View this code on Github\rUsage of our new \u0026ldquo;upgraded\u0026rdquo; Filesystem copy_file() might now be as follows:\n// Non-throwing use case\r auto o = filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;);\rif(!o)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with error \u0026#34; \u0026lt;\u0026lt; o.error().ec.message() //\r \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; o.error().path1 \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; o.error().path2 \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //\r \u0026lt;\u0026lt; std::endl;\r}\r// Throwing use case\r try\r{\r// Try to observe the successful value, thus triggering default actions which invokes\r // our throw_as_system_error_with_payload() above which then throws filesystem_error\r // exactly like the Filesystem TS does for its throwing overload.\r filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;).value();\r}\rcatch(const filesystem2::filesystem_error \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //\r \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; e.path2() \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //\r \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //\r \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/builtin/",
	"title": "Built-in policies",
	"tags": [],
	"description": "",
	"content": "These are the precanned policies built into Outcome:\n all_narrow Wide checks call their narrow check cousins only. Narrow checks call a function called _ub() which:\n Is marked with any compiler-specific markup to say it will never return, which should cause the compiler\u0026rsquo;s optimiser to generate perfectly minimum code. Calls __builtin_unreachable() on compilers which support that intrinsic to further encourage perfectly minimum code (and to trigger the undefined behaviour sanitiser if execution ever reaches such a code path).  error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; Policy interpreting either EC as meeting the std::error_code contract, and EP as optionally meeting the std::exception_ptr contract. If there is no value and EP is set to an exception ptr, .value() will std::rethrow_exception(exception) or std::rethrow_exception(make_exception_ptr(exception)). If there is no value and EP is not set to an exception ptr, .value() will OUTCOME_THROW_EXCEPTION(std::system_error(error)) or OUTCOME_THROW_EXCEPTION(std::system_error(make_error_code(error))) if EC is implicitly convertible to a std::error_code, or is an error code enum or error condition enum, otherwise it will invoke the ADL discovered free function throw_as_system_error_with_payload(error). .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) or OUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no error\u0026quot;)) if there is no error. .exception() willOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no exception\u0026quot;)) if there is no exception. The narrow checks are the same as for the all_narrow policy.\n exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; Policy interpreting either or both EC and EP as meeting the std::exception_ptr contract. If there is no value, .value() will std::rethrow_exception(error) or std::rethrow_exception(make_exception_ptr(error)) if EP is void, else std::rethrow_exception(exception) or std::rethrow_exception(make_exception_ptr(exception)) or std::rethrow_exception(error) or std::rethrow_exception(make_exception_ptr(error)) as appropriate. .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) or OUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no error\u0026quot;)) if there is no error. .exception() willOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no exception\u0026quot;)) if there is no exception. The narrow checks are the same as for the all_narrow policy.\n terminate Wide checks call std::terminate if they fail. The narrow checks are the same as for the all_narrow policy.\n throw_bad_result_access\u0026lt;EC\u0026gt; Policy implementing throws of bad_result_access_with\u0026lt;EC\u0026gt;. .value() will OUTCOME_THROW_EXCEPTION(bad_result_access_with\u0026lt;EC\u0026gt;(error)) if there is no value, .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) if there is no error. The narrow checks are the same as for the all_narrow policy. This policy can be used with outcome, but any EP state is ignored and will appear to the policy as if neither value nor error is set, so .value() in this situation would OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no value\u0026quot;)).\n  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example2/",
	"title": "Calling it from C",
	"tags": [],
	"description": "",
	"content": "Now let us call our result returning C++ function from C:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt; // for strerror\r// This header in Outcome is pure C, it provides a suite of C helper macros\r#include \u0026#34;../../../include/outcome/result.h\u0026#34;\r\r// Declare our C++ function\u0026#39;s returning result type. Only needs to be done once.\rCXX_DECLARE_RESULT_EC(size_t, size_t);\r// Tell C about our C++ function\rextern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v);\rvoid print(int v)\r{\rchar buffer[4];\rCXX_RESULT_EC(size_t) res;\rres = to_string(buffer, sizeof(buffer), v);\rif(CXX_RESULT_HAS_VALUE(res))\r{\rprintf(\u0026#34;to_string(%d) fills buffer with \u0026#39;%s\u0026#39; of %zu characters\\n\u0026#34;, v, buffer, res.value);\rreturn;\r}\r// Is the error returned in the std::generic_category domain and thus an errno?\r if(CXX_RESULT_ERROR_IS_ERRNO(res))\r{\r// If you get a weird compile error here, note that CXX_RESULT_ERROR()\r // uses C11 generics, you need a C11 compiler for it to work. If you don\u0026#39;t\r // have a C11 compiler, res.error or res.error.code can be used directly.\r fprintf(stderr, \u0026#34;to_string(%d) failed with error code %d (%s)\\n\u0026#34;, v, CXX_RESULT_ERROR(res), strerror(CXX_RESULT_ERROR(res)));\rreturn;\r}\rfprintf(stderr, \u0026#34;to_string(%d) failed with unknown error code %d\\n\u0026#34;, v, CXX_RESULT_ERROR(res));\r}\rint main(void)\r{\rprint(9);\rprint(99);\rprint(999);\rprint(9999);\rreturn 0;\r}\r View this code on Github\rRunning this C program yields:\nto_string(9) fills buffer with '9' of 1 characters to_string(99) fills buffer with '99' of 2 characters to_string(999) fills buffer with '999' of 3 characters to_string(9999) failed with error code 105 (No buffer space available)  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/",
	"title": "Custom payloads",
	"tags": [],
	"description": "Success-or-failure return types where extra information in addition to the error code accompanies failure.",
	"content": "So far, type EC in result\u0026lt;T, EC\u0026gt; has always been a std::error_code. But it need in fact to merely satisfy trait::has_error_code_v\u0026lt;EC\u0026gt; for EC to be treated as a std::error_code.\nIn turn, trait::has_error_code_v\u0026lt;EC\u0026gt; is true if there exists some ADL discovered free function called make_error_code(EC) returning a std::error_code, or if EC is implicitly convertible into a std::error_code.\nThus, we can in fact use any custom EC type we like, including one carrying additional information, or payload. This payload can carry anything you like, and you can tell Outcome to do various things with that payload under various circumstances. For example:\n If the user tries to observe an unsuccessful result, throw a custom exception containing the cause of failure with accompanying context from the payload. If the user ever constructs an outcome from a payload carrying result, set the exception ptr in the constructed outcome to a custom exception containing the cause of the failure with accompanying context from the payload. Transmit a stack backtrace specifying the exact point at which failure occurred, symbolising that into human readable text at the moment of conversion into human readable text. Upon a namespace-localised result from library A being copy/moved into a namespace-localised result from C bindings library B, set the C errno if the error code and category map onto the errno domain.  There are many, many other options of course. This tutorial can only cover a reasonable subset. This section covers Example 1 above, throwing custom exceptions with payload upon observation of an unsuccessful result.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "    Is Outcome safe to use in extern APIs? Does Outcome have a stable ABI? Is Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? What kind of performance benefits will using Outcome in my code bring? Why is implicit default construction disabled? How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design?    Is Outcome safe to use in extern APIs? Outcome is specifically designed for use in the public interfaces of multi-million line codebases. Its layout is hard coded to:\nstruct { T value; unsigned int flags; EC error; };  This is, of course, C-compatible and Outcome provides a macro-based C interface for C code needing to call extern \u0026quot;C\u0026quot; C++ functions returning a result\u0026lt;T, EC\u0026gt;.\nDoes Outcome have a stable ABI? Until Outcome passes a second Boost peer review and enters Boost, no. Once into Boost, Outcome\u0026rsquo;s ABI will be formally fixed as the v2 ABI one year after its first Boost release. Thereafter the ABI compliance checker will be run per-commit to ensure Outcome\u0026rsquo;s ABI remains stable.\nIs Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? Great care has been taken to ensure that Outcome never unexpectedly executes anything with unbounded execution times such as malloc(), dynamic_cast\u0026lt;\u0026gt;() or throw. Outcome works perfectly with C++ exceptions and RTTI globally disabled.\nOutcome\u0026rsquo;s entire design premise is that its users are happy to exchange a small, predictable constant overhead during successful code paths, in exchange for completely predictable failure code paths. In contrast, table-based exception handling gives zero run time overhead for the successful code path, and completely unpredictable (and very expensive) overhead for failure code paths.\nFor code where predictability of execution no matter the code path is paramount, writing all your code to use Outcome is not a bad place to start. Obviously enough, do choose a non-throwing policy when configuring outcome or result such as policy::all_narrow to guarantee that exceptions can never be thrown by Outcome (or use the convenience typedef for result, unchecked which uses policy::all_narrow).\nWhat kind of performance benefits will using Outcome in my code bring? It is very hard to say anything definitive about performance impacts in codebases one has never seen. Each codebase is unique. However to come up with some form of measure, we timed returning an error via each of the main mechanisms, doing so over ten stack frames. A stack frame is defined to be something called by the compiler whilst unwinding the stack between the point of returning the error and the thing which handles the error, so for example ten stack allocated objects might be destructed, or ten levels of stack depth might be unwound. This is not a particularly realistic test, but it should at least give one an idea of the performance impact of returning Outcome\u0026rsquo;s result or outcome over say returning a plain integer, or throwing an exception.\n Log graph comparing GCC 7.2, clang 5.0, Visual Studio 2017.5 and XCode 8.2   As you can see, throwing and catching an exception is expensive on table-based exception handling implementations such as these, anywhere between 16,000 and 36,000 CPU cycles. Simple integer returns are always going to be the fastest as they do the least work, and that costs 90 to 100 CPU cycles.\nNote that returning a result\u0026lt;int, std::error_code\u0026gt; with an int (result-error-value) is no additional runtime overhead over returning a naked int on most compilers.\nReturning a result\u0026lt;int, std::error_code\u0026gt; with an error code (result-error-error) is no additional runtime overhead over returning a naked int on most compilers.\nYou might wonder what happens if type E has a non-trivial destructor, thus making the result\u0026lt;T, E\u0026gt; have a non-trivial destructor? We tested E = std::exception_ptr and found no performance difference to E = std::error_code for returning a value. Returning an error was obviously much slower at anywhere between 300 and 1,500 CPU cycles due to returning an exception pointer being at least two atomic operations per stack frame, but that is still two orders of magnitude better than throwing and catching an exception.\nWe conclude that if failure is anything but extremely rare in your C++ codebase, using Outcome instead of throwing and catching exceptions ought to be quicker overall.\nWhy is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome. Here are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on no-value) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on no-error). (checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers)  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; requires E to be default constructible. checked\u0026lt;T, E\u0026gt; defaults E to std::error_code. Expected does not default E.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the differing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`.\rIt passes the reference test suite for P0323R3 at\rhttps://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications\ronly to move the test much closer to the P0323R3 Expected, as the reference test suite is for a\rmuch older proposed Expected.\rKnown differences from P0323R3 in this implementation:\r- `T` and `E` cannot be the same type.\r- `E` must be default constructible.\r- No variant storage is implemented (note the Expected proposal does not actually require this).\r*/\rnamespace detail\r{\rtemplate \u0026lt;class T, class E\u0026gt; using expected_result = BOOST_OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;;\rtemplate \u0026lt;class T, class E\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt;\r{\rusing base = expected_result\u0026lt;T, E\u0026gt;;\rusing base::base;\rconstexpr enable_default_constructor()\r: base{BOOST_OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;}\r{\r}\r};\rtemplate \u0026lt;class T, class E\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;;\r}\rtemplate \u0026lt;class T, class E\u0026gt; class expected : public detail::select_expected_base\u0026lt;T, E\u0026gt;\r{\rstatic_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;);\rusing base = detail::select_expected_base\u0026lt;T, E\u0026gt;;\rpublic:\r// Inherit base\u0026#39;s constructors\r using base::base;\rexpected() = default;\r// Expected takes in_place not in_place_type\r template \u0026lt;class... Args\u0026gt;\rconstexpr explicit expected(std::in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args)\r: base{BOOST_OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}\r{\r}\r// Expected always accepts a T even if ambiguous\r BOOST_OUTCOME_TEMPLATE(class U)\rBOOST_OUTCOME_TREQUIRES(BOOST_OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value))\rconstexpr expected(U \u0026amp;\u0026amp;v)\r: base{BOOST_OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)}\r{\r}\r// Expected has an emplace() modifier\r template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{BOOST_OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; }\r// Expected has a narrow operator* and operator-\u0026gt;\r constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); }\rconstexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); }\rconstexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); }\rconstexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); }\rconstexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); }\rconstexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); }\r// Expected has a narrow error() observer\r constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); }\rconstexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); }\rconstexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); }\rconstexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); }\r};\rtemplate \u0026lt;class E\u0026gt; class expected\u0026lt;void, E\u0026gt; : public BOOST_OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, BOOST_OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;\r{\rusing base = BOOST_OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, BOOST_OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;;\rpublic:\r// Inherit base constructors\r using base::base;\r// Expected has a narrow operator* and operator-\u0026gt;\r constexpr void operator*() const { base::assume_value(); }\rconstexpr void operator-\u0026gt;() const { base::assume_value(); }\r};\rtemplate \u0026lt;class E\u0026gt; using unexpected = BOOST_OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;;\rtemplate \u0026lt;class E\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg)\r{\rreturn BOOST_OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg));\r}\rtemplate \u0026lt;class E, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args)\r{\rreturn BOOST_OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...);\r}\rtemplate \u0026lt;class E\u0026gt; using bad_expected_access = BOOST_OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;;\r View this code on Github\rWhy doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design? There are a number of reasons:\n Outcome is not aimed at the same audience as Expected. We target developers and users who would be happy to use Boost. Expected targets the standard library user. Outcome believes that the monadic use case isn\u0026rsquo;t as important as Expected does. Specifically, we think that 99% of use of Expected in the real world will be to return failure from functions, and not as some sort of enhanced or \u0026ldquo;rich\u0026rdquo; Optional. Outcome therefore models a subset of Variant, whereas Expected models an extended Optional. Outcome believes that if you are thinking about using something like Outcome, then for you writing failure code will be in the same proportion as writing success code, and thus in Outcome writing for failure is exactly the same as writing for success. Expected assumes that success will be more common than failure, and makes you type more when writing for failure. Outcome goes to considerable effort to help the end user type fewer characters during use. This results in tighter, less verbose, more succinct code. The cost of this is a steeper learning curve and more complex mental model than when programming with Expected. Outcome has facilities to make easier interoperation between multiple third party libraries each using incommensurate Outcome configurations. Expected does not do any of this, but subsequent WG21 papers do propose various interoperation mechanisms, one of which Outcome implements so code using Expected will seamlessly interoperate with code using Outcome.  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_result/",
	"title": "Hook result",
	"tags": [],
	"description": "",
	"content": "We now tell Outcome that for every instance of our localised result\u0026lt;T\u0026gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.\nnamespace error_code_extended\r{\r// Specialise the result construction hook for our localised result\r // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace\r // if the result is errored.\r template \u0026lt;class T, class U\u0026gt; inline void hook_result_construction(result\u0026lt;T\u0026gt; *res, U \u0026amp;\u0026amp; /*unused*/) noexcept\r{\rif(res-\u0026gt;has_error())\r{\r// Grab the next extended info slot in the TLS\r extended_error_info \u0026amp;eei = mythreadlocaldata().next();\r// Write the index just grabbed into the spare uint16_t\r BOOST_OUTCOME_V2_NAMESPACE::hooks::set_spare_storage(res, mythreadlocaldata().current - 1);\r// Capture a backtrace into my claimed extended info slot in the TLS\r eei.items = ::backtrace(eei.backtrace.data(), eei.backtrace.size());\r}\r}\r}\r View this code on Github\rThe only non-obvious part above is the call to hooks::set_spare_storage(). Both result and outcome keep their internal state metadata in a uint32_t, half of which is not used by Outcome. As it can be very useful to keep a small unique number attached to any particular result or outcome instance, we permit user code to set those sixteen bits to anything they feel like. The corresponding function to retrieve those sixteen bits is hooks::spare_storage().\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/outcome/inspecting/",
	"title": "Inspecting outcome&lt;T, EC, EP&gt;",
	"tags": [],
	"description": "",
	"content": "Continuing with the previous example, in Layer3 we obtain an outcome\u0026lt;double\u0026gt; which may store a double or an std::error_code or an std::exception_ptr. Layer3 uses exceptions to indicate failure, so we want to turn a failed result into an exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_codes:\nnamespace Layer3\r{\rauto run() -\u0026gt; double // may throw\r {\rif (outcome::outcome\u0026lt;double\u0026gt; o = Layer2NX::fun())\rreturn o.value();\relse if (o.has_exception())\rstd::rethrow_exception(o.exception());\relse\rthrow std::system_error{o.error()};\r} }\r View this code on Github\rFunction has_exception checks if it is EP (std::exception_ptr) that is stored, function exception accesses it. Similarly, function error accesses the EC (std::error_code) if it is stored. outcome\u0026lt;\u0026gt; has also function has_failure to check if either EC or EP is being stored. In fact, this pattern of \u0026ldquo;unpacking\u0026rdquo; outcome\u0026lt;\u0026gt; is so common that it has been implemented inside function value, so function Layer3::run could be written as:\nreturn Layer2NX::fun().value(); "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib1/",
	"title": "Mapping the HTTP library into the Application 1/2",
	"tags": [],
	"description": "",
	"content": "Firstly we are going to need to wrap up httplib::failure into a custom STL exception type before we can type erase it into an exception_ptr instance. Please note that this code is defined in the app namespace:\nnamespace app\r{\r// Specialise an exception type for httplib errors\r struct httplib_error : std::runtime_error\r{\r// passthrough\r using std::runtime_error::runtime_error;\rhttplib_error(httplib::failure _failure, std::string msg)\r: std::runtime_error(std::move(msg))\r, failure(std::move(_failure))\r{\r}\r// the original failure\r httplib::failure failure;\r};\r// Type erase httplib::result\u0026lt;U\u0026gt; into a httplib_error exception ptr\r template \u0026lt;class U\u0026gt; inline std::exception_ptr make_httplib_exception(const httplib::result\u0026lt;U\u0026gt; \u0026amp;src)\r{\rstd::string str(\u0026#34;httplib failed with error \u0026#34;);\rswitch(src.error().status)\r{\rcase httplib::status_code::success:\rstr.append(\u0026#34;success\u0026#34;);\rbreak;\rcase httplib::status_code::bad_request:\rstr.append(\u0026#34;bad request\u0026#34;);\rbreak;\rcase httplib::status_code::access_denied:\rstr.append(\u0026#34;access denied\u0026#34;);\rbreak;\rcase httplib::status_code::logon_failed:\rstr.append(\u0026#34;logon failed\u0026#34;);\rbreak;\rcase httplib::status_code::forbidden:\rstr.append(\u0026#34;forbidden\u0026#34;);\rbreak;\rcase httplib::status_code::not_found:\rstr.append(\u0026#34;not found\u0026#34;);\rbreak;\rcase httplib::status_code::internal_error:\rstr.append(\u0026#34;internal error\u0026#34;);\rbreak;\r}\rstr.append(\u0026#34; [url was \u0026#34;);\rstr.append(src.error().url);\rstr.append(\u0026#34;]\u0026#34;);\rreturn std::make_exception_ptr(httplib_error(src.error(), std::move(str)));\r}\r}\r View this code on Github\rThe only real thing to note about app::httplib_error is that it squirrels away the original httplib::failure in case that is ever needed. We do, of course, need to create some sort of descriptive string for std::runtime_error so its .what() returns a useful summary of the original failure. This is the purpose of the app::make_httplib_exception() function.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/static-constructor/",
	"title": "Phase 2 construction",
	"tags": [],
	"description": "",
	"content": "Its phase 2 constructor:\n// Phase 2 static member constructor function, which cannot throw\rinline outcome::result\u0026lt;file_handle\u0026gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept\r{\r// Perform phase 1 of object construction\r file_handle ret;\r// Perform phase 2 of object construction\r int flags = 0;\rswitch(mode)\r{\rcase mode::attr_read:\rcase mode::read:\rflags = O_RDONLY;\rbreak;\rcase mode::attr_write:\rcase mode::write:\rflags = O_RDWR;\rbreak;\rcase mode::append:\rflags = O_APPEND;\rbreak;\rdefault:\rreturn std::errc::invalid_argument;\r}\rret._fd = ::open(path.u8string().c_str(), flags);\rif(-1 == ret._fd)\r{\r// Note that if we bail out here, ~file_handle() will correctly not call ::close()\r return {errno, std::system_category()};\r}\rif(-1 == ::fstat(ret._fd, \u0026amp;ret._stat))\r{\r// Note that if we bail out here, ~file_handle() will correctly call ::close()\r return {errno, std::system_category()};\r}\r// Returning ret directly is an area full of compiler specific behaviour quirks,\r // so be explicit by wrapping into an initialiser list with embedded move.\r return {std::move(ret)};\r}\r View this code on Github\rThe static member function implementing phase 2 firstly calls phase 1 which puts the object into a legally destructible state. We then proceed to implement phase 2 of construction, filling in the various parts as we go, reporting via result any failures.\nRemember that operator new has a non-throwing form, new(std::nothrow).\n\rFor the final return, in theory we could just return ret and depending on the C++ version currently in force, it might work via move, or via copy, or it might refuse to compile. You can of course type lots of boilerplate to be explicit, but this use via initialiser list is a reasonable balance of explicitness versus brevity, and it should generate minimum overhead code irrespective of compiler, C++ version, or any other factor.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/try/",
	"title": "TRY operations",
	"tags": [],
	"description": "",
	"content": "In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRY:\nOUTCOME_TRY (i, BigInt::fromString(text));  This control statement is raughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto\u0026amp;\u0026amp; i = __result.value();  Where __result is a unique name.\nAdditionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text));  This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i);  or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;));  This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n\rMacro OUTCOME_TRY does two things: 1. It extracts a T from result\u0026lt;T\u0026gt; (or outcome\u0026lt;T\u0026gt;). 2. It declares a dependency between statements: If the \u0026ldquo;tried\u0026rdquo; statement fails, the next statement is not executed.\nWhen you are calling functions that return result\u0026lt;void\u0026gt; the first of the two things does not make sense. You then have to use macro OUTCOME_TRYV instead. Let\u0026rsquo;s use our function print_half:\noutcome::result\u0026lt;void\u0026gt; test()\r{\rBOOST_OUTCOME_TRYV (print_half(\u0026#34;2\u0026#34;));\rBOOST_OUTCOME_TRYV (print_half(\u0026#34;X\u0026#34;));\rBOOST_OUTCOME_TRYV (print_half(\u0026#34;4\u0026#34;)); // will not execute\r return outcome::success();\r}\r View this code on Github\rThe first statement will succeed. The second statement will \u0026ldquo;fail\u0026rdquo;, i.e. it will return an errored result. This will cause an immediate return and the subsequent statements will be skipped.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/error-codes/",
	"title": "error_code",
	"tags": [],
	"description": "",
	"content": "Now that we have told the C++ standard library about our custom error code enum err, we actually no longer need to specify EC = err, we can just leave it default to std::error_code:\nresult\u0026lt;udt /*, std::error_code */\u0026gt; res(err::failure1);\r// What happens here? What exception type is thrown?\r try\r{\rstd::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\r// Prints \u0026#34;Exception thrown was failure1\u0026#34;, exactly the same as before\r std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\rThe reason that this works is because std::error_code provides implicit construction from any type with the trait std::is_error_code_enum\u0026lt;\u0026gt; defined to be true, it uses the ADL discovered free function make_error_code() during that implicit construction.\nThe big advantage of always using EC = std::error_code is that OUTCOME_TRY only works when the EC type is the same in the try expression as the calling function, so by leaving it at the default of std::error_code, we can use OUTCOME_TRY and save having to type boilerplate:\nresult\u0026lt;udt\u0026gt; boo()\r{\rreturn err::failure1;\r}\rresult\u0026lt;udt\u0026gt; foo()\r{\rBOOST_OUTCOME_TRY(v, boo());\rreturn {5}; // emplace construct udt with 5\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib2/",
	"title": "Mapping the HTTP library into the Application 2/2",
	"tags": [],
	"description": "",
	"content": "If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:\n// Inject custom ValueOrError conversion\rBOOST_OUTCOME_V2_NAMESPACE_BEGIN\rnamespace convert\r{\r// Provide custom ValueOrError conversion from httplib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;\r template \u0026lt;class T, class U\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, httplib::result\u0026lt;U\u0026gt;\u0026gt;\r{\r// False to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`\r static constexpr bool enable_result_inputs = true;\r// False to indicate that this converter wants `outcome` to NOT reject all other `outcome`\r static constexpr bool enable_outcome_inputs = true;\rtemplate \u0026lt;class X, //\r typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;httplib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //\r \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //\r constexpr app::outcome\u0026lt;T\u0026gt;\roperator()(X \u0026amp;\u0026amp;src)\r{\r// Forward any successful value, else synthesise an exception ptr\r return src.has_value() ? //\r app::outcome\u0026lt;T\u0026gt;{std::forward\u0026lt;X\u0026gt;(src).value()} //\r :\rapp::outcome\u0026lt;T\u0026gt;{app::make_httplib_exception(std::forward\u0026lt;X\u0026gt;(src))};\r}\r};\r}\rBOOST_OUTCOME_V2_NAMESPACE_END\r View this code on Github\rThe first thing that you should note is that these custom converters must be injected directly into the OUTCOME_V2_NAMESPACE::convert namespace, and they must partially or completely specialise struct value_or_error\u0026lt;DEST, SRC\u0026gt;.\nThe second thing to note is that you need to set enable_result_inputs and enable_outcome_inputs appropriately. The reason that these are here is because of a chicken-or-egg problem whereby the ValueOrError infrastructure needs to be defined before result can be defined, and we also wish to permit inclusion of result without needing to include outcome. So this is a slightly irritating workaround, but one with low impact.\nThe third thing to note is the SFINAE on operator(). If the SFINAE fails, the ValueOrError converting constructor disables. Obviously, if you are using Concept requirements, that works too. Note the requirement that SFINAEd X matches httplib::result\u0026lt;U\u0026gt;, and that T is constructible from U.\nIf operator() is available, it naturally converts a httplib::result\u0026lt;U\u0026gt; into an app::outcome\u0026lt;T\u0026gt; by either forwarding any success as-is, or calling app::make_httplib_exception() to type erase the httplib::failure into an app::httplib_error.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/poke_exception/",
	"title": "Custom exception ptr",
	"tags": [],
	"description": "",
	"content": "If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.\nBut let\u0026rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:\nnamespace error_code_extended\r{\r// Synthesise a custom exception_ptr from the TLS slot and write it into the outcome\r template \u0026lt;class R\u0026gt; inline void poke_exception(outcome\u0026lt;R\u0026gt; *o)\r{\rif(o-\u0026gt;has_error())\r{\rextended_error_info *eei = mythreadlocaldata().get(BOOST_OUTCOME_V2_NAMESPACE::hooks::spare_storage(o));\rif(eei != nullptr)\r{\r// Make a custom string for the exception\r std::string str(o-\u0026gt;error().message());\rstr.append(\u0026#34; [\u0026#34;);\rchar **symbols = ::backtrace_symbols(eei-\u0026gt;backtrace.data(), eei-\u0026gt;items);\rif(symbols != nullptr)\r{\rfor(size_t n = 0; n \u0026lt; eei-\u0026gt;items; n++)\r{\rif(n \u0026gt; 0)\r{\rstr.append(\u0026#34;; \u0026#34;);\r}\rstr.append(symbols[n]);\r}\r::free(symbols); // not exception safe, could leak symbols if appending str fails\r }\rstr.append(\u0026#34;]\u0026#34;);\r// Override the payload/exception member in the outcome with our synthesised exception ptr\r BOOST_OUTCOME_V2_NAMESPACE::hooks::override_outcome_exception(o, std::make_exception_ptr(std::runtime_error(str)));\r}\r}\r}\r}\r View this code on Github\rIf the localised outcome being constructed is errored, try fetching the TLS slot for the unique 16-bit value in its spare storage. If that is valid, symbolise the stack backtrace into a string and make an exception ptr with a runtime error with that string. Finally, override the payload/exception member in our just-copy-constructed localised outcome with the new exception ptr.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-filelib/",
	"title": "Mapping the File I/O library into the Application",
	"tags": [],
	"description": "",
	"content": "To handle the File I/O library, once again we turn to custom ValueOrError converters:\n// Inject custom ValueOrError conversion\rBOOST_OUTCOME_V2_NAMESPACE_BEGIN\rnamespace convert\r{\r// Provide custom ValueOrError conversion from filelib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;\r template \u0026lt;class T, class U\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, filelib::result\u0026lt;U\u0026gt;\u0026gt;\r{\r// True to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`\r static constexpr bool enable_result_inputs = true;\r// False to indicate that this converter wants `outcome` to NOT reject all other `outcome`\r static constexpr bool enable_outcome_inputs = true;\rtemplate \u0026lt;class X, //\r typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;filelib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //\r \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //\r constexpr app::outcome\u0026lt;T\u0026gt;\roperator()(X \u0026amp;\u0026amp;src)\r{\r// Forward any successful value\r if(src.has_value())\r{\rreturn {std::forward\u0026lt;X\u0026gt;(src).value()};\r}\r// Synthesise a filesystem_error, exactly as if someone had called src.value()\r auto \u0026amp;fi = src.error();\rBOOST_OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // might throw\r return {std::make_exception_ptr(filelib::filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec))};\r}\r};\r}\rBOOST_OUTCOME_V2_NAMESPACE_END\r View this code on Github\rNote that the conversion exactly duplicates the implementation of throw_as_system_error_with_payload(failure_info fi) from namespace filelib.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg1/",
	"title": "Phase 3",
	"tags": [],
	"description": "",
	"content": "We have built our first two phases of construction for file_handle, and for some users they might be happy writing:\noutcome::result\u0026lt;file_handle\u0026gt; fh1 = file_handle::file(\u0026#34;hello\u0026#34; /*, file_handle::mode::read */);\rif(!fh1)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh1.error().message() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\r\u0026hellip; and be done with it.\nBut wouldn\u0026rsquo;t it be nicer if we could instead write:\noutcome::result\u0026lt;file_handle\u0026gt; fh2 = construct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34; /*, file_handle::mode::read */}();\rif(!fh2)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh2.error().message() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\rThe eye is immediately drawn to the two-stage invocation pattern, so we are constructing a type construct\u0026lt;file_handle\u0026gt; using the arguments with which we wish to invoke the file_handle constructor with, and then invoking the call operator on that construct\u0026lt;file_handle\u0026gt; instance to do the actual construction.\nWe think that this is a better approach than alternatives, but we shall briefly cover those at the end of this section.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/variations/",
	"title": "Variations",
	"tags": [],
	"description": "",
	"content": "You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with CXX_DECLARE_RESULT(t_ident, t_decl, e_ident, e_decl), refer to it with CXX_RESULT(t_ident, e_ident) and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =\nstruct cxx_error_code { int code; void *category; };  \u0026hellip; which is declared for you by result.h.\nOutcome\u0026rsquo;s C support was designed assuming that you do not wish to penalise the performance of C++ code calling these C-compatible C++ functions, but if you don\u0026rsquo;t care about that, then always setting errno to any error in a result\u0026lt;T\u0026gt; is easily implemented and thus the natural C use pattern becomes available:\nextern size_t to_string(char *buffer, size_t bufferlen, int v); ... size_t len = to_string(buffer, sizeof(buffer), v); if(errno != 0) ...  Implementing this via boilerplate generating script is straightforward, and is left as an exercise to the interested reader.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/videos/",
	"title": "Videos",
	"tags": [],
	"description": "",
	"content": " Outcome has been presented at some of the major C++ conferences as it has evolved. As the older content is less relevant to Outcome today, this list is given in reverse chronological order.\nMeeting C++ 2017 \u0026ldquo;Introduction to proposed std::expected\u0026lt;T, E\u0026gt;\u0026ldquo; Literature review of the several WG21 papers relating to std::expected.\nAwaiting video\n ACCU 2017 \u0026ldquo;Mongrel Monads, Dirty, dirty, dirty\u0026rdquo; Covers the history of error handling in C++, and how the LEWG Expected works.\n(Note that the Expected presented here no longer exists, it was substantially changed after the Outcome v1 peer review. Furthermore the Outcome presented here no longer exists, the peer review demanded a complete rebuild)\n   "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/exception-ptr/",
	"title": "exception_ptr",
	"tags": [],
	"description": "",
	"content": "Another default action exists for result\u0026lt;T, EC\u0026gt; where trait::has_exception_ptr\u0026lt;EC\u0026gt; is true, and for outcome\u0026lt;T, EC, EP\u0026gt; where either or both trait::has_exception_ptr\u0026lt;EC\u0026gt; and trait::has_exception_ptr\u0026lt;EP\u0026gt; is true.\nThis default action simply rethrows the exception pointer via std::rethrow_exception(make_exception_ptr(.error())) for result and std::rethrow_exception(make_exception_ptr(.error())) and/or std::rethrow_exception(make_exception_ptr(.exception())) for outcome, if trait::has_exception_ptr\u0026lt;EC\u0026gt; and/or trait::has_exception_ptr\u0026lt;EP\u0026gt; is true.\nstruct udt\r{\rint a{0};\rexplicit udt(int _a)\r: a(_a)\r{\r}\rudt() = default;\rint operator*() const { return a; }\r};\rresult\u0026lt;udt, std::exception_ptr\u0026gt; res(std::make_exception_ptr(std::runtime_error(\u0026#34;hello\u0026#34;)));\r// What happens here? What exception type is thrown?\r try\r{\rstd::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\rRunning this yields:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_exception_ptr Exception thrown was hello ned@lyta:~/outcome/build_posix$  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/",
	"title": "Default actions",
	"tags": [],
	"description": "The default rules for handling different categories of failure type",
	"content": "In the last section, we observed with .value() the value of the outcome returned by copy_file() and saw that it may throw a C++ exception configured by an ADL discovered function. This behaviour is what we will call a \u0026ldquo;default action\u0026rdquo; i.e. a pre-programmed action taken by Outcome in response to no-value observation.\nSome \u0026ndash; strongly \u0026ndash; feel that these value-or-error objects should not have any \u0026ldquo;default action\u0026rdquo; other than to throw a special exception carrying as payload the cause of the no-value i.e. the error. Most with this opinion feel that the \u0026ldquo;default action\u0026rdquo; is in fact to unwind the stack, and that using an exception throw instead of a function return is basically the same thing precisely because a stack unwind occurs in both cases, and the mechanism by which that is achieved isn\u0026rsquo;t particularly important. Indeed, the Expected proposal before WG21, which intends to standardise a value-or-error object not dissimilar to Outcome\u0026rsquo;s objects, does just this (at the time of writing). Optional, which is a value-or-nothing object, similarly throws a special exception on no-value observation via .value().\nOutcome\u0026rsquo;s default is to not provide value-or-error objects. It provides success-or-failure objects. We define the difference as being \u0026ldquo;having programmable actions in response to no-value observation other than throwing a hard coded logic error type exception1\u0026rdquo;. This philosophical difference implies that throwing a C++ exception is solely used to abort the current operation with a useful-to-the-programmer default action, not as a control flow alternative to ordinary returns from function, not for reporting \u0026ldquo;recoverable\u0026rdquo; logic errors.\nYou can, of course, choose different default actions for your particular Outcome instance, implement your own default actions, and indeed configure a result and outcome which throw a logic error type exception exactly the same way as Expected or Optional does. How to do this is described later in this tutorial.\nThis section describes the default actions implemented by Outcome, which we believe will cover the large majority of users with no further configuration needed.\n I take exception to throwing logic error type exceptions as is unfortunately the case throughout the C++ standard library. What actual value to the programmer do they deliver? If used as control flow, then there are always much superior alternatives. If used for spotting a true logic error, then you just detected bad logic by the programmer or memory corruption, in which case this situation is not recoverable and you really ought to fatal exit. And then consider all the many negatives: (i) you force programmers to have to deal with exception safety, substantially increasing development costs for virtually no gain to the programmer (ii) you force the compiler to have to deal with potential exception throws, slowing down compile times and generating bloatier code just in case something which should almost never happen might occur (iii) analysis tooling can\u0026rsquo;t tell between control flow and logic error type exception throws, and thus cannot spot nor warn you when you didn\u0026rsquo;t mean them to occur.On table-based exception handling implementations, throwing an exception is assumed to be extremely rare. This allows zero performance impact on the non-throwing code paths, but at a very severe performance cost to any time that you throw and catch an exception. This is unavoidable in any table-based exception handling implementation. A throw...catch cycle is always at least thousands of times more expensive than a return statement, and always must be so, even when the throw...catch is inlined on current compiler technology.\r[return]   "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-tidylib/",
	"title": "Mapping the HTMLTidy library into the Application",
	"tags": [],
	"description": "",
	"content": "Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.\nnamespace app\r{\r// Specialise an exception type for tidylib errors\r struct tidylib_error : std::system_error\r{\r// passthrough\r using std::system_error::system_error;\rtidylib_error() = default;\rexplicit tidylib_error(int c)\r: std::system_error(c, std::generic_category())\r{\r}\r};\r// Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,\r // returing a unique_ptr to release storage on scope exit.\r struct call_free\r{\rtemplate \u0026lt;class T\u0026gt; void operator()(T *p) { ::free(p); }\r};\rinline outcome\u0026lt;std::unique_ptr\u0026lt;char, call_free\u0026gt;\u0026gt; tidy_html(string_view \u0026amp;data)\r{\rchar *out = nullptr;\rsize_t outlen = 0;\rint errcode = ::tidy_html(\u0026amp;out, \u0026amp;outlen, data.data(), data.size());\rif(errcode != 0)\r{\r// If the error code matches a standard STL exception, throw as that.\r BOOST_OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(std::error_code(errcode, std::generic_category()));\r// Otherwise wrap the error code into a tidylib_error exception throw\r return std::make_exception_ptr(tidylib_error(errcode));\r}\r// Reset input view to tidied html\r data = string_view(out, outlen);\r// Return a unique ptr to release storage on scope exit\r return std::unique_ptr\u0026lt;char, call_free\u0026gt;(out);\r}\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/",
	"title": "Result returning constructors",
	"tags": [],
	"description": "How to metaprogram construction of objects which use result&lt;T, EC&gt; to return failure instead of throwing a C++ exception.",
	"content": "An oft asked question during conference talks on Expected/Outcome is how to exclusively use result to implement constructor failure. This is asked because whilst almost every member function in a class can return a result, constructors do not return values and thus cannot return a result. The implication is that one cannot avoid throwing C++ exceptions to abort a construction.\nAs with most things in C++, one can achieve zero-exception-throw object construction using a lot of extra typing of boilerplate, and a little bit of simple C++ metaprogramming. This section shows you how to implement these for those who are absolutely adverse to ever throwing an exception, or cannot because C++ exceptions have been globally disabled.\nThe technique described here is not suitable for non-copyable and non-movable types. There is also an assumption that moving your type is cheap.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_outcome/",
	"title": "Hook outcome",
	"tags": [],
	"description": "",
	"content": "The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn\u0026rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.\nnamespace error_code_extended\r{\r// Specialise the outcome copy and move conversion hook for when our localised result\r // is used as the source for copy construction our localised outcome\r template \u0026lt;class T, class U\u0026gt; inline void hook_outcome_copy_construction(outcome\u0026lt;T\u0026gt; *res, const result\u0026lt;U\u0026gt; \u0026amp; /*unused*/) noexcept\r{\r// when copy constructing from a result\u0026lt;T\u0026gt;, poke in an exception\r poke_exception(res);\r}\rtemplate \u0026lt;class T, class U\u0026gt; inline void hook_outcome_move_construction(outcome\u0026lt;T\u0026gt; *res, result\u0026lt;U\u0026gt; \u0026amp;\u0026amp; /*unused*/) noexcept\r{\r// when move constructing from a result\u0026lt;T\u0026gt;, poke in an exception\r poke_exception(res);\r}\r}\r View this code on Github\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/",
	"title": "Hooking events",
	"tags": [],
	"description": "Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.",
	"content": "Outcome provides multiple methods for user code to intercept various events which occur. The deepest is simply to inherit from result or outcome and override member functions. Another possible option is to supply a custom NoValuePolicy (see next section). The final option which this section covers is to use the ADL discovered event hooks which tell you when a namespace-localised outcome or result has been:\n Constructed  hook_result_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src) hook_outcome_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)  In-place constructed  hook_result_in_place_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src) hook_outcome_in_place_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)  Copied  hook_result_copy_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src) hook_outcome_copy_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)  Moved  hook_result_move_construction(result\u0026lt;T, E\u0026gt; *this, in_place_type_t\u0026lt;T|E\u0026gt;, Args\u0026amp;\u0026amp;... srcs) hook_outcome_move_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, in_place_type_t\u0026lt;T|EC|EP\u0026gt;, Args\u0026amp;\u0026amp;... srcs)   One criticism often levelled against these success-or-failure objects is that they do not provide as rich a set of facilities as C++ exception throws. This section shows you how to configure Outcome using the ADL event hooks to take a stack backtrace on construction of an errored result\u0026lt;T, error_code\u0026gt;, and if that result\u0026lt;T, error_code\u0026gt; should ever be converted into an outcome\u0026lt;T, error_code, std::exception_ptr\u0026gt;, a custom std::exception_ptr will be synthesised consisting of the std::system_error for the error code, plus an expanded message string containing the stack backtrace of where the error originally occurred.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-go/",
	"title": "In use",
	"tags": [],
	"description": "",
	"content": "This is how you might now write application code using these three libraries:\nnamespace app\r{\routcome\u0026lt;void\u0026gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc\r {\r// Note that explicit construction is required when converting between differing types\r // of outcome and result. This makes it explicit what you intend to do as conversion\r // may be a lot more expensive than moves.\r\r// Try to GET this URL. If an unsuccessful HTTP status is returned, serialise a string\r // containing a description of the HTTP status code and the URL which failed, storing\r // that into a httplib_error exception type which is stored as an exception ptr. The\r // TRY operation below will return that exception ptr to be rethrown in the caller.\r // Otherwise the fetched data is returned in a std::string data.\r BOOST_OUTCOME_TRY(data, outcome\u0026lt;std::string\u0026gt;(httplib::get(\u0026#34;http://www.nedproductions.biz/\u0026#34;)));\rstring_view data_view(data);\r// HTML tidy the fetched data. If the C library fails due to an error corresponding to\r // a standard library exception type, throw that. Otherwise, synthesise an exception\r // ptr of type tidylib_error which stores the error code returned in an error code with\r // generic category (i.e. errno domain).\r // TRY operation below will return that exception ptr to be rethrown in the caller.\r // Otherwise the tidied data is returned into holdmem, with the string view updated to\r // point at the tidied data.\r BOOST_OUTCOME_TRY(holdmem, tidy_html(data_view));\r// Write the tidied data to some file. If the write fails, synthesise a filesystem_error\r // exception ptr exactly as if one called filelib::write_file(data_view).value().\r BOOST_OUTCOME_TRY(written, outcome\u0026lt;size_t\u0026gt;(filelib::write_file(data_view)));\rreturn success();\r}\r}\r View this code on Github\rMany will wish that the explicit converting wrappers around third party library APIs were not there. Note that in C++ 17 you should be able to dispense with the angle bracketed type as the compiler can now deduce that. But one must still wrap all third party API invocations with outcome() i.e. explicit construction to namespace-localised outcome. This is a deliberate design decision: in Outcome, all converting construction is always explicit, except when the source is success or failure type sugar. And down the line when others come to maintain this code, we think it will be very useful to be explicit on this because user defined code that we customised earlier is being executed.\nNote also that we are able to use TRY throughout this function, and most especially note that we never, at any stage, needed to modify the source code of httplib, tidylib nor filelib, or inject custom things into their namespaces. This entire worked example was achieved solely by app based customisation points and via convert.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg2/",
	"title": "construct&lt;T&gt;",
	"tags": [],
	"description": "",
	"content": "First, we need a base definition for construct\u0026lt;T\u0026gt;:\ntemplate \u0026lt;class T\u0026gt; struct construct\r{\routcome::result\u0026lt;T\u0026gt; operator()() const noexcept\r{ //\r static_assert(!std::is_same\u0026lt;T, T\u0026gt;::value, \u0026#34;construct\u0026lt;T\u0026gt;() was not specialised for the type T supplied\u0026#34;);\r}\r};\r View this code on Github\rThis fails a static assert if the type is ever instantiated unspecialised.\nWe then specialise for construct\u0026lt;file_handle\u0026gt;:\ntemplate \u0026lt;\u0026gt; struct construct\u0026lt;file_handle\u0026gt;\r{\rfile_handle::path_type _path;\rfile_handle::mode _mode{file_handle::mode::read};\r// Any other args, default initialised if necessary, follow here ...\r\routcome::result\u0026lt;file_handle\u0026gt; operator()() const noexcept { return file_handle::file(std::move(_path)); }\r};\r View this code on Github\rBecause this is a struct, we can list initialise construct, and use default member initialisers to implement default arguments. This can get you surprisingly far before you need to start writing custom constructors.\nBut in more complex code, you will usually provide all the initialisation overloads that you would for the constructors of your main type. You then implement a single phase 2 constructing function which accepts construct\u0026lt;YOURTYPE\u0026gt; as input, and construct solely from that source.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/void/",
	"title": "void",
	"tags": [],
	"description": "",
	"content": "What about result\u0026lt;udt, void\u0026gt;? This is absolutely legal, it means that no error state is returned when there was an error. This can help with clarifying in code the use of std::optional\u0026lt;udt\u0026gt; as Optional more logically means value-or-nothing, not necessarily value-or-error.\nIn contrast, result\u0026lt;udt, void\u0026gt; unambiguously does mean success-or-failure, just with an unspecified cause of failure.\nOutcome\u0026rsquo;s default action for EC = void is to call std::terminate:\nstruct udt\r{\rint a{0};\rexplicit udt(int _a)\r: a(_a)\r{\r}\rudt() = default;\rint operator*() const { return a; }\r};\rresult\u0026lt;udt, void\u0026gt; res(in_place_type\u0026lt;void\u0026gt;);\r// What happens here? What exception type is thrown?\r try\r{\rstd::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl;\r}\rcatch(const std::exception \u0026amp;e)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;\r}\r View this code on Github\rRunning this yields:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_void_terminate terminate called without an active exception Aborted (core dumped) ned@lyta:~/outcome/build_posix$  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace.\nHowever there are occasions when you don\u0026rsquo;t have control over the implementation of the destination E type e.g. in callbacks. Outcome\u0026rsquo;s ValueOrError infrastructure lets you inject custom interop code for any pair of incommensurate third party E types, without needing to modify either\u0026rsquo;s source code. This is without doubt a \u0026ldquo;power users\u0026rdquo; feature, but one which will prove useful as T|E based C++ code proliferates.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg3/",
	"title": "Alternatives",
	"tags": [],
	"description": "",
	"content": "No doubt many will dislike the two-stage invocation pattern i.e.\nconstruct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34;}();  So let us examine the most obvious alternative: a templated free function construct\u0026lt;T\u0026gt;.\nDue to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.\ntemplate\u0026lt;class... Args\u0026gt; inline outcome::result\u0026lt;file_handle\u0026gt; construct(std::in_place_type_t\u0026lt;file_handle\u0026gt;, Args\u0026amp;\u0026amp; ... args) { return file_handle::file(std::forward\u0026lt;Args\u0026gt;(args)...); } ... // Now you must always write this: construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026#34;hello\u0026#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:\n It takes longer to type construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026quot;hello\u0026quot;), and is possibly less intuitive to write, than it does construct\u0026lt;file_handle\u0026gt;{\u0026quot;hello\u0026quot;}(). Compiler error messages are enormously clearer if you encode the permitted overloads for construction into the construct\u0026lt;file_handle\u0026gt; type rather than letting a variadic free function fail to resolve an appropriate overload. Resolving variadic free function overloads is not constant time for the compiler, whereas resolving the type specialisation for construct\u0026lt;file_handle\u0026gt; is constant time. It actually turns out to be quite useful when writing generic code to pass around object constructing factory objects all of which have no parameters for their call operator. It becomes, effectively, a lazy construction mechanism.  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/",
	"title": "Policies",
	"tags": [],
	"description": "Defining your own NoValuePolicy policies, plus an overview of the precanned policies which come in the Outcome source code.",
	"content": "Earlier in the section on Default actions, we covered all the different actions which Outcome can take upon no-value observation, and we noted that this facility is fully programmable.\nresult\u0026lt;T, EC\u0026gt; is actually result\u0026lt;T, EC, NoValuePolicy\u0026gt;. outcome\u0026lt;T, EC, EP\u0026gt; is in fact outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;. The NoValuePolicy template type is defaulted to a template alias as follows:\nnamespace policy { template \u0026lt;class T, class EC, class E\u0026gt; using default_policy = std::conditional_t\u0026lt; std::is_void\u0026lt;EC\u0026gt;::value \u0026amp;\u0026amp; std::is_void\u0026lt;E\u0026gt;::value, terminate, std::conditional_t\u0026lt; trait::has_error_code_v\u0026lt;EC\u0026gt;, error_code_throw_as_system_error\u0026lt;T, EC, E\u0026gt;, std::conditional_t\u0026lt; trait::has_exception_ptr_v\u0026lt;EC\u0026gt; || trait::has_exception_ptr_v\u0026lt;E\u0026gt;, exception_ptr_rethrow\u0026lt;T, EC, E\u0026gt;, all_narrow \u0026gt;\u0026gt;\u0026gt;; }   For unchecked\u0026lt;T, EC\u0026gt;, NoValuePolicy is hard coded to policy::all_narrow. For checked\u0026lt;T, EC\u0026gt;, NoValuePolicy is hard coded to policy::throw_bad_result_access\u0026lt;EC\u0026gt;.   These exactly match the Default Actions described earlier.\nThis section describes what a NoValuePolicy looks like, how to write your own, and each of the prewritten policies supplied with Outcome.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/unchecked/",
	"title": "unchecked&lt;T, E&gt; and checked&lt;T, E&gt;",
	"tags": [],
	"description": "",
	"content": "We have now covered all of the default actions in Outcome whereby result\u0026lt;T, EC\u0026gt; and outcome\u0026lt;T, EC, EP|P\u0026gt; implement various default actions upon no-value observation according to traits defined upon the EC and EP|P chosen.\nIf you don\u0026rsquo;t want all this clever automatic detection of traits, and just want a plain, always-undefined-behaviour-on-no-value-observation success-or-failure type, we provide a simplified template alias to result\u0026lt;T, E\u0026gt; called unchecked\u0026lt;T, E\u0026gt;. It literally does no run time checking whatsoever, no-value observation is always undefined behaviour.\nIf instead you would prefer a plain, always-throwing-logic-error-on-no-value-observation type, we also provide another simplified template alias to result\u0026lt;T, E\u0026gt; called checked\u0026lt;T, E\u0026gt;. Similar to .value() in the WG21 Expected proposal or Optional, no-value observation throws these logic error type exceptions:\n No-value .value() observation throws bad_result_access_with\u0026lt;E\u0026gt;. No-error .error() observation throws bad_result_access.  If you need run time unchecked observers, .assume_value() and .assume_error() are always unchecked at run time.\nFinally, if you would like to implement your own default actions, you will find the tutorial section on Policies useful.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/",
	"title": "Using result&lt;T&gt; from C code",
	"tags": [],
	"description": "Interacting with result&lt;T, EC&gt; returning C++ functions from C code.",
	"content": "A long standing problem for C code (or more usually nowadays, the many other programming languages which can speak the C ABI but not the C++ ABI) is how to interpret C++ exception throws. The answer is of course that they cannot, thus requiring one to write C shim code on the C++ side of things of the form:\n// The API we wish to expose to C const char *get_value(double v); // The C shim function for the C++ get_value() function. extern \u0026#34;C\u0026#34; int c_get_value(const char **ret, double v) { try { *ret = get_value(v); return 0; // success  } catch(const std::range_error \u0026amp;) { return ERANGE; } // More catch clauses may go in here ...  catch(...) { return EAGAIN; } }  This is sufficiently painful that most reach for a bindings generator tool like SWIG to automate this sort of tedious boilerplate generation. And this is fine for larger projects, but for smaller projects the cost of setting up and configuring SWIG is also non-trivial.\nWhat would be really great is if result\u0026lt;T\u0026gt; returning noexcept C++ functions could be used straight from C. And indeed Outcome provides just that facility which this section covers next.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/",
	"title": "Interoperation",
	"tags": [],
	"description": "Interoperating with std::expected&lt;T, E&gt; and other ValueOrError concept matching types.",
	"content": "This is the final section of the tutorial, and it is unavoidably quite lengthy.\nOne thing which Outcome solves \u0026ndash; which alternatives do not \u0026ndash; is how to non-intrusively tie together multiple third party libraries, each using Outcome with custom incommensurate E types, or indeed arbitrary return types which are \u0026ldquo;split\u0026rdquo; T|E return types. Solving this well is the coup de gr√¢ce of Outcome against alternative approaches to this problem domain, including std::expected\u0026lt;T, E\u0026gt;. It is the major reason why you should consider using Outcome over alternatives, including Expected.\nFirstly we shall explore some of the problems faced by the software developer when T|E return type based code proliferates at scale, where dozens of libraries may be using completely incompatible T|E return types.\nSecondly we shall introduce the ValueOrError concept support in Outcome which implements a subset of the proposed ValueOrError concept framework.\nFinally, we shall then step through a worked example which mocks up a realistic situation that the software developer may find themselves in: tying together disparate third party libraries, whose source code cannot be modified, into an application-wide, mixed-mode T|E and exception throwing universal error handling system which is capable of accurately representing the original failure, but also propagating it in a way that the application can deal with universally.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt\rdateFormat YYYY-MM\rtitle History of the Outcome library\rOutcome v1: done, des1, 2014-06,2017-05\rBoost peer review of v1: done, des2, after des1, 30d\rOutcome v2: active, des3, after des2, 365d\rsection Events\rSeparated from AFIO v1: crit, done, 2014-06,2d\rBoost.Expected added: crit, done, 2014-10,2d\rBoost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d\rNon-allocating future-promise implementation dropped: crit, done, 2016-05,2d\rC++ 11 support dropped: crit, done, 2016-06,2d\rImplemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d\rOutcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d\rBoost.Outcome generated by script from Outcome repo: crit, done, 2017-10,2d\r The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo; and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available. All that remained before it was ready for a second Boost peer review was the documentation.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/error_code/",
	"title": "Custom error codes",
	"tags": [],
	"description": "Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.",
	"content": "This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in conveting an std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;string\u0026gt; // for string printing\r#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al\r\r// This is the custom error code enum\renum class ConversionErrc\r{\rEmptyString = 1, // 0 is never an error\r IllegalChar = 2,\rTooLong = 3,\r};\rnamespace std\r{\r// Tell the C++ 11 STL metaprogramming that enum MathError::valid_errors\r // is registered with the standard error code system\r template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type\r{\r};\r}\rnamespace detail\r{\r// Define a custom error code category derived from std::error_category\r class ConversionErrc_category : public std::error_category\r{\rpublic:\r// Return a short descriptive name for the category\r virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; }\r// Return what each enum means in text\r virtual std::string message(int c) const override final\r{\rswitch (static_cast\u0026lt;ConversionErrc\u0026gt;(c))\r{\rcase ConversionErrc::EmptyString:\rreturn \u0026#34;converting empty string\u0026#34;;\rcase ConversionErrc::IllegalChar:\rreturn \u0026#34;got non-digit chatr when converting to a number\u0026#34;;\rcase ConversionErrc::TooLong:\rreturn \u0026#34;the number would not fit into memory\u0026#34;;\rdefault:\rreturn \u0026#34;unknown\u0026#34;;\r}\r}\r// OPTIONAL: Allow generic error conditions to be compared to me\r virtual std::error_condition default_error_condition(int c) const noexcept override final\r{\rswitch (static_cast\u0026lt;ConversionErrc\u0026gt;(c))\r{\rcase ConversionErrc::EmptyString:\rreturn make_error_condition(std::errc::invalid_argument);\rcase ConversionErrc::IllegalChar:\rreturn make_error_condition(std::errc::invalid_argument);\rcase ConversionErrc::TooLong:\rreturn make_error_condition(std::errc::result_out_of_range);\rdefault:\r// I have no mapping for this code\r return std::error_condition(c, *this);\r}\r}\r};\r}\r// Declare a global function returning a static instance of the custom category\rextern const detail::ConversionErrc_category \u0026amp;ConversionErrc_category()\r{\rstatic detail::ConversionErrc_category c;\rreturn c;\r}\r// Overload the global make_error_code() free function with our\r// custom enum. It will be found via ADL by the compiler if needed.\rinline std::error_code make_error_code(ConversionErrc e)\r{\rreturn {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()};\r}\rint main(void)\r{\r// Note that we can now supply ConversionErrc directly to error_code\r std::error_code ec = ConversionErrc::IllegalChar;\rstd::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34;\r\u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl;\r// We can compare ConversionErrc containing error codes to generic conditions\r std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34;\r\u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl;\rstd::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34;\r\u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl;\rreturn 0;\r}\r View this code on Github\rThis might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{\rdisplay:flex;\rflex-flow: wrap;\ralign-content: flex-start\r}\r.ghContributors  div{\rwidth: 50% ;\rdisplay: inline-flex;\rmargin-bottom: 5px;\r}\r.ghContributors  div label{\rpadding-left: 4px ;\r}\r.ghContributors  div span{\rfont-size: x-small;\rpadding-left: 4px ;\r}\r\r\r@ned14\r652 commits\r\r\r@akrzemi1\r9 commits\r\r\r@jenkins-nedprod\r1 commits\r\r This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library Outcome is a C++14 library for reporting and handling function failures. It can be used as a substitute for, or a complement to, exception handling mechanism.\nOne use case is for contexts where using C++ exception handling is unsuitable for different reasons:\n The high relative cost of throwing and catching a C++ exception, Making some or all control paths explicitly detailed to aid code correctness auditing, as opposed to having hidden control paths caused by exceptions potentially thrown from any place, Company\u0026rsquo;s policy to compile with exceptions disabled, Maintaining a code base that was never designed with exception-safety in mind, Parts of the programs/frameworks that themselves implement exception handling and cannot afford to use exceptions, like propagating failure reports across threads, tasks, fibers\u0026hellip;  Another use case is to replace \u0026lsquo;dual\u0026rsquo; interfaces, like ones in Boost.Filesystem, where almost each function comes in two overloads, one throwing an exception, the other populating an error_code output argument. With Outcome, you can have only one function returning a composite return type, and it is through using this return value that you decide whether to handle failures locally, or to launch stack unwinding.\nOutcome can also be used to plug components that potentially throw exceptions into parts of the program that are not exception-safe while retaining all information from the thrown exception objects.\nSample usage Function that may need to report failure needs to reflect that in its return type:\nauto read_int_from_file(string_view path) noexcept\r-\u0026gt; outcome::result\u0026lt;int\u0026gt;;\r View this code on Github\rFunction read_int_from_file will either return an int or information about the reason for failure.\nIt is possible to inspect the returned state manualy:\nif (auto rslt = read_int_from_file(\u0026#34;config.cfg\u0026#34;))\ruse_int(rslt.value());\relse\rreport_error(rslt.error()); // returns std::error_code\r View this code on Github\rBut most of the time you would inspect the object indirectly through a dedicated control statement. An implementation of read_int_from_file that has to (1) open the file, (2) read raw data to a buffer, and (3) interpret it as int, using the following three functions\nauto open_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;Handle\u0026gt;;\rauto read_data(Handle\u0026amp; h) noexcept -\u0026gt; outcome::result\u0026lt;Buffer\u0026gt;; auto parse(const Buffer\u0026amp; b) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;\r View this code on Github\rwill look like this:\nauto read_int_from_file(string_view path) noexcept\r-\u0026gt; outcome::result\u0026lt;int\u0026gt;\r{\rBOOST_OUTCOME_TRY(handle, open_file(path)); // decltype(handle) == Handle\r BOOST_OUTCOME_TRY(buffer, read_data(handle)); // decltype(buffer) == Buffer\r BOOST_OUTCOME_TRY(val, parse(buffer)); // decltype(val) == int\r return val;\r}\r View this code on Github\rEach occurance of OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; contains an error information, the function is immediately returned with result\u0026lt;U\u0026gt; containing the same error information; otherwise object of type T is move-constructed on the stack.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review expected for the end of 2017.\n\r"
},
{
	"uri": "http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]